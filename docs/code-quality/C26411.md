---
title: C26411
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26411
helpviewer_keywords:
- C26411
ms.assetid: 5134e51e-8b92-4ee7-94c3-022e318a0e24
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 84d58747dd0d3bc6c5d742a5e9d44280c7f26d04
ms.sourcegitcommit: 485ffaedb1ade71490f11cf05962add1718945cc
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/16/2019
ms.locfileid: "72446527"
---
# <a name="c26411--no_ref_to_unique_ptr"></a>C26411 NO_REF_TO_UNIQUE_PTR

Il passaggio di un puntatore univoco per riferimento presuppone che la relativa risorsa possa essere rilasciata o trasferita all'interno di una funzione di destinazione. Se la funzione usa solo il parametro per accedere alla risorsa, è possibile passare un puntatore non elaborato o un riferimento.

## <a name="remarks"></a>Note

- Di seguito sono riportate le limitazioni relative all'avviso [C26410](C26410.md) .

- L'euristica per rilevare l'accesso "release" o "reset" al puntatore univoco è piuttosto ingenua: vengono rilevate solo le chiamate agli operatori di assegnazione e alle funzioni denominate "reset" (senza distinzione tra maiuscole e minuscole). Ovviamente, questo rilevamento non copre tutti i possibili casi di modifiche intelligenti del puntatore, ad esempio std:: swap o qualsiasi funzione speciale non const in un puntatore intelligente personalizzato. Si prevede che questo avviso produrrà molti falsi positivi sui tipi personalizzati, oltre ad alcuni scenari che riguardano i puntatori univoci standard. L'euristica verrà migliorata quando si implementano più controlli incentrati sui puntatori intelligenti.

- Il fatto che i puntatori intelligenti siano spesso modelli comporta una limitazione interessante per il fatto che il compilatore non deve elaborare il codice del modello nei modelli se non viene utilizzato. In alcune basi di codice minime che hanno un uso limitato delle interfacce del puntatore intelligente, il controllo può produrre risultati imprevisti a causa dell'impossibilità di identificare correttamente la semantica del tipo di modello (perché alcune funzioni importanti potrebbero non essere mai usate). Per lo standard `unique_pointer`, questa limitazione viene attenuata riconoscendo il nome del tipo. Questo può essere esteso in futuro per coprire i puntatori intelligenti più noti.

- Le espressioni lambda con acquisizione implicita per riferimento possono causare avvisi sorprendenti sui riferimenti a puntatori univoci. Attualmente vengono segnalati tutti i parametri di riferimento acquisiti nelle espressioni lambda, indipendentemente dal fatto che vengano reimpostati o meno. L'euristica verrà estesa in modo da correlare i campi lambda con i parametri lambda in una versione futura.

## <a name="example-unnecessary-reference"></a>Esempio: riferimento non necessario

```cpp
void TraceValid(std::unique_ptr<Slot> &slot)    // C26411
{
    if (!IsDamaged(slot.get()))
        std::cout << *slot.get();
}

void ReleaseValid(std::unique_ptr<Slot> &slot)  // OK
{
    if (!IsDamaged(slot.get()))
        slot.reset(nullptr);
}
```
