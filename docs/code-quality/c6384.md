---
title: C6384
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 837d31002f75995fc55d29045500e093bf1ca69c
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/07/2019
ms.locfileid: "72017419"
---
# <a name="c6384"></a>C6384
avviso C6384: divisione di un puntatore sizeof per un altro valore

 Questo avviso indica che un calcolo delle dimensioni potrebbe non essere corretto. Per calcolare il numero di elementi in una matrice, una a volte divide la dimensione della matrice in base alla dimensione del primo elemento. Tuttavia, quando la matrice è effettivamente un puntatore, il risultato è in genere diverso da quello previsto.

 Se il puntatore è un parametro di funzione e le dimensioni del buffer non sono state passate, non è possibile calcolare il buffer massimo disponibile. Quando il puntatore viene allocato localmente, è necessario utilizzare la dimensione utilizzata nell'allocazione.

## <a name="example"></a>Esempio
 Il codice seguente genera questo avviso:

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);
  }
}
```

 Per correggere il problema, passare le dimensioni del buffer, come illustrato nel codice seguente:

```
#include <windows.h>
#include <TCHAR.h>

#define SIZE 15

void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
    _tcsncpy(dest, src, SIZE);
  }
}
```

 Per correggere questo avviso usando la funzione di stringa Safe _tcsncpy_s, usare il codice seguente:

```
void f( )
{
  LPTSTR dest = new TCHAR[SIZE];
  char src [SIZE] = "Hello, World!!";
  if (dest)
  {
   _tcsncpy_s(dest, SIZE, src, SIZE);
  }
}
```

 Si noti che l'uso di New e Delete presenta molti problemi in termini di perdite di memoria ed eccezioni. Per evitare completamente questi tipi di perdite e problemi di eccezione, utilizzare i meccanismi forniti dalla libreria STL ( C++ Standard Template Library). Sono inclusi [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class)e [vector](/cpp/standard-library/vector). Per altre informazioni, vedere [puntatori intelligenti](/cpp/cpp/smart-pointers-modern-cpp) e [ C++ libreria standard](/cpp/standard-library/cpp-standard-library-reference).

## <a name="see-also"></a>Vedere anche

- [_mbsnbcpy_s, _mbsnbcpy_s_l](/cpp/c-runtime-library/reference/mbsnbcpy-s-mbsnbcpy-s-l)
- [Operatore sizeof](/cpp/cpp/sizeof-operator)