---
title: 'CA1303: Non passare valori letterali come parametri localizzati'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CPP
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 33d82ac6400b4ca4cae37fd5a63600407b18b543
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/01/2020
ms.locfileid: "75570791"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: Non passare valori letterali come parametri localizzati

|||
|-|-|
|TypeName|DoNotPassLiteralsAsLocalizedParameters|
|CheckId|CA1303|
|Categoria|Microsoft. globalizzazione|
|Modifica|Senza interruzioni|

## <a name="cause"></a>Causa

Un metodo passa un valore letterale stringa come parametro a un costruttore o a un metodo .NET e tale stringa deve essere localizzabile.

Questo avviso viene generato quando una stringa letterale viene passata come valore a un parametro o a una proprietà e uno o più dei seguenti casi è true:

- L'attributo <xref:System.ComponentModel.LocalizableAttribute> del parametro o della proprietà è impostato su true.

- Il nome del parametro o della proprietà contiene "Text", "message" o "Caption".

- Il nome del parametro stringa passato a un metodo Console. Write o console. WriteLine può essere "value" o "Format".

Per impostazione predefinita, questa regola analizza l'intera codebase, ma può essere [configurata](#configurability).

## <a name="rule-description"></a>Descrizione della regola

I valori letterali stringa incorporati nel codice sorgente sono difficili da localizzare.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni

Per correggere una violazione di questa regola, sostituire il valore letterale stringa con una stringa recuperata tramite un'istanza della classe <xref:System.Resources.ResourceManager>.

## <a name="when-to-suppress-warnings"></a>Quando escludere gli avvisi

È possibile eliminare un avviso da questa regola se la libreria di codice non viene localizzata o se la stringa non è esposta all'utente finale o a uno sviluppatore che usa la libreria di codice.

Gli utenti possono eliminare il rumore da metodi che non devono essere passati a stringhe localizzate rinominando il parametro o la proprietà o contrassegnando questi elementi come condizionale.

## <a name="configurability"></a>Configurabilità

Se questa regola viene eseguita da [analizzatori FxCop](install-fxcop-analyzers.md) (e non con analisi legacy), questa regola può essere configurata.

### <a name="excluded-type-names-with-derived-types"></a>Nomi di tipi esclusi con tipi derivati

È possibile configurare i tipi, inclusi i tipi derivati, da escludere dall'analisi. Ad esempio, per specificare che la regola non deve essere eseguita in alcun metodo all'interno di tipi denominati `MyType` e i tipi derivati, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formati dei nomi di simboli consentiti nel valore dell'opzione (separati da' |'):
  - Solo nome del tipo (include tutti i tipi con il nome, indipendentemente dal tipo o dallo spazio dei nomi che lo contiene)
  - Nomi completi nel formato dell'ID di [documentazione](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)del simbolo, con un prefisso `T:` facoltativo.

Esempi:

| Valore dell'opzione | Riepilogo |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Corrisponde a tutti i tipi denominati ' MyType ' e a tutti i relativi tipi derivati nella compilazione
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Corrisponde a tutti i tipi denominati ' MyType1' o ' MyType2' e tutti i relativi tipi derivati nella compilazione
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Corrisponde al tipo specifico ' MyType ' con il nome completo specificato e tutti i relativi tipi derivati
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Corrisponde ai tipi specifici ' MyType1' è MyType2' con i rispettivi nomi completi e tutti i relativi tipi derivati

È possibile configurare questa opzione solo per questa regola, per tutte le regole o per tutte le regole in questa categoria (globalizzazione). Per altre informazioni, vedere [configurare gli analizzatori FxCop](configure-fxcop-analyzers.md).

## <a name="example"></a>Esempio

Nell'esempio seguente viene illustrato un metodo che genera un'eccezione quando uno dei due argomenti non è compreso nell'intervallo. Per il primo argomento, al costruttore di eccezione viene passata una stringa letterale che viola questa regola. Per il secondo argomento, al costruttore viene passata correttamente una stringa recuperata tramite un <xref:System.Resources.ResourceManager>.

[!code-cpp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CPP/ca1303-do-not-pass-literals-as-localized-parameters_1.cpp)]
[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Vedere anche

- [Risorse nelle applicazioni desktop](/dotnet/framework/resources/index)
