---
title: 'CA1303: Non passare valori letterali come parametri localizzati'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- Do not pass literals as localized parameters
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
helpviewer_keywords:
- DoNotPassLiteralsAsLocalizedParameters
- CA1303
ms.assetid: 904d284e-76d0-4b8f-a4df-0094de8d7aac
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 40d819831e56e943de29fc08731aa910e930ac47
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "88710728"
---
# <a name="ca1303-do-not-pass-literals-as-localized-parameters"></a>CA1303: Non passare valori letterali come parametri localizzati

|Elemento|valore|
|-|-|
|CheckId|CA1303|
|Category|Microsoft. globalizzazione|
|Modifica|Senza interruzioni|

## <a name="cause"></a>Causa

Un metodo passa un valore letterale stringa come parametro a un costruttore o a un metodo .NET e tale stringa deve essere localizzabile.

Questo avviso viene generato quando una stringa letterale viene passata come valore a un parametro o a una proprietà e uno o più dei seguenti casi è true:

- L' <xref:System.ComponentModel.LocalizableAttribute> attributo del parametro o della proprietà è impostato su true.

- Il nome del parametro stringa passato a un metodo Console. Write o console. WriteLine può essere "value" o "Format".

Per impostazione predefinita, questa regola analizza l'intera codebase, ma può essere [configurata](#excluded-type-names-with-derived-types).

A partire dalla versione 3.0.0 del pacchetto dell'analizzatore, l'euristica di denominazione non viene più usata per impostazione predefinita, ma può essere [configurata](#use-naming-heuristic).

## <a name="rule-description"></a>Descrizione della regola

I valori letterali stringa incorporati nel codice sorgente sono difficili da localizzare.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni

Per correggere una violazione di questa regola, sostituire il valore letterale stringa con una stringa recuperata tramite un'istanza della <xref:System.Resources.ResourceManager> classe.

## <a name="when-to-suppress-warnings"></a>Quando escludere gli avvisi

È possibile eliminare un avviso da questa regola se la libreria di codice non viene localizzata o se la stringa non è esposta all'utente finale o a uno sviluppatore che usa la libreria di codice.

Gli utenti possono eliminare il rumore da metodi che non devono essere passati a stringhe localizzate rinominando il parametro o la proprietà o contrassegnando questi elementi come condizionale.

## <a name="configurability"></a>Configurabilità

Questa regola include le opzioni configurabili seguenti.

### <a name="excluded-type-names-with-derived-types"></a>Nomi di tipi esclusi con tipi derivati

È possibile configurare i tipi, inclusi i tipi derivati, da escludere dall'analisi. Ad esempio, per specificare che la regola non deve essere eseguita in alcun metodo all'interno di tipi denominati `MyType` e i tipi derivati, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType
```

Formati dei nomi di simboli consentiti nel valore dell'opzione (separati da' |'):

- Solo nome del tipo (include tutti i tipi con il nome, indipendentemente dal tipo o dallo spazio dei nomi che lo contiene)
- Nomi completi nel formato dell'ID di [documentazione](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)del simbolo con `T:` prefisso facoltativo.

Esempi:

| Valore dell'opzione | Riepilogo |
| --- | --- |
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType` | Corrisponde a tutti i tipi denominati ' MyType ' e a tutti i relativi tipi derivati nella compilazione
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = MyType1|MyType2` | Corrisponde a tutti i tipi denominati ' MyType1' o ' MyType2' e tutti i relativi tipi derivati nella compilazione
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS.MyType` | Corrisponde al tipo specifico ' MyType ' con il nome completo specificato e tutti i relativi tipi derivati
|`dotnet_code_quality.CA1303.excluded_type_names_with_derived_types = M:NS1.MyType1|M:NS2.MyType2` | Corrisponde ai tipi specifici ' MyType1' è MyType2' con i rispettivi nomi completi e tutti i relativi tipi derivati

È possibile configurare questa opzione solo per questa regola, per tutte le regole o per tutte le regole in questa categoria (globalizzazione). Per altre informazioni, vedere [configurare gli analizzatori di qualità del codice .NET](configure-fxcop-analyzers.md).

### <a name="use-naming-heuristic"></a>Usa euristica di denominazione

È possibile specificare se il nome di parametri o proprietà che contiene "testo", "messaggio" o "didascalia" attiverà questa regola.

```ini
dotnet_code_quality.CA1303.use_naming_heuristic = true
```

## <a name="example"></a>Esempio

Nell'esempio seguente viene illustrato un metodo che genera un'eccezione quando uno dei due argomenti non è compreso nell'intervallo. Per il primo argomento, al costruttore di eccezione viene passata una stringa letterale che viola questa regola. Per il secondo argomento, al costruttore viene passata correttamente una stringa recuperata tramite <xref:System.Resources.ResourceManager> .

[!code-vb[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/VisualBasic/ca1303-do-not-pass-literals-as-localized-parameters_1.vb)]
[!code-csharp[FxCop.Globalization.DoNotPassLiterals#1](../code-quality/codesnippet/CSharp/ca1303-do-not-pass-literals-as-localized-parameters_1.cs)]

## <a name="see-also"></a>Vedere anche

- [Risorse nelle app desktop](/dotnet/framework/resources/index)
- [Richiesta di modifica del comportamento della community](https://github.com/dotnet/roslyn-analyzers/issues/2933)
