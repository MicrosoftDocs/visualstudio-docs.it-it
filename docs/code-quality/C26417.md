---
title: C26417 | Documenti Microsoft
ms.custom: ''
ms.date: 11/15/2017
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26417
helpviewer_keywords:
- C26417
ms.assetid: 0e09fcc6-f9eb-4404-b51e-5815705c6afb
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 7c0e84ae9dd4d4860e9ab1a0dc65c737d7e95d3e
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/16/2018
---
# <a name="c26417-nolvaluerefsharedptr"></a>C26417 NO_LVALUE_REF_SHARED_PTR
"Puntatore condiviso parametro passato per riferimento e non è stato reimpostato o riassegnato. Utilizzare T * o T & invece. "

**Linee guida dei componenti di base di C++**:   
R.35: Richiedere un shared_ptr<widget>& parametro express che una funzione potrebbe ricollegare puntatore condiviso

Il passaggio di puntatori condivisi per riferimento può essere utile in scenari in cui il codice chiamato Aggiorna la destinazione dell'oggetto puntatore intelligente e il relativo chiamante si aspetta di trovare tali aggiornamenti. Utilizzo di un riferimento esclusivamente per ridurre i costi di passare un puntatore condiviso è in discussione. Se il codice chiamato accede solo oggetto di destinazione e mai gestisce la durata, è preferibile passare il puntatore non elaborato o un riferimento, anziché per esporre i dettagli di gestione delle risorse.

## <a name="remarks"></a>Note
-  Questo controllo riconosce std::shared_pointer e tipi definiti dall'utente che possono comportarsi come puntatori condivisi. Le seguenti caratteristiche sono previste per puntatori condivisi definiti dall'utente:
-  di overload dereferenziare o operatori (pubblici e non è stato eliminato), accesso ai membri
-  costruttore di copia o operatore di assegnazione di copia (pubblici e non è stato eliminato).
-  distruttore pubblico che non viene eliminato né impostate come predefinito. Distruttori vuoti vengono conteggiati ancora come definito dall'utente.
-  L'azione di ripristino o la riassegnazione viene interpretato in modo più generico:
-  qualsiasi chiamata a un metodo non costante in un puntatore condiviso potenzialmente possibile reimpostare il puntatore.
-  qualsiasi chiamata a una funzione che accetta un riferimento a un puntatore di tipo condiviso non costante può potenzialmente reimpostare o riassegnare tale puntatore.

## <a name="example"></a>Esempio 
complicazione interfaccia necessaria

```cpp
bool unregister(std::shared_ptr<event> &e) // C26417, also C26415 SMART_PTR_NOT_NEEDED
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e))
        e = std::make_shared<event>(e->id());
    // ...
}
```

## <a name="example"></a>Esempio 
complicazione interfaccia inutili - semplificato

```cpp
bool unregister(const event *e)
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e.get()))
        e = std::make_shared<event>(e->id());
    // ...
}
```

