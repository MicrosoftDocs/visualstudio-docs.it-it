---
title: C26417 | Documenti Microsoft
ms.custom: 
ms.date: 11/15/2017
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C26417
helpviewer_keywords: C26417
ms.assetid: 0e09fcc6-f9eb-4404-b51e-5815705c6afb
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: 3891a9be76d8b1e2faa3764fc8f561f0c9c08df4
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/22/2017
---
# <a name="c26417-nolvaluerefsharedptr"></a>C26417 NO_LVALUE_REF_SHARED_PTR
"Puntatore condiviso parametro passato per riferimento e non è stato reimpostato o riassegnato. Utilizzare T * o T & invece. "

**Linee guida di base C++**:   
R.35: Richiedere un shared_ptr<widget>& parametro express che una funzione potrebbe ricollegare puntatore condiviso

Il passaggio di puntatori condivisi per riferimento può essere utile in scenari in cui il codice chiamato Aggiorna la destinazione dell'oggetto puntatore intelligente e il relativo chiamante si aspetta di trovare tali aggiornamenti. Utilizzo di un riferimento esclusivamente per ridurre i costi di passare un puntatore condiviso è in discussione. Se il codice chiamato accede solo oggetto di destinazione e mai gestisce la durata, è preferibile passare il puntatore non elaborato o un riferimento, anziché per esporre i dettagli di gestione delle risorse.

## <a name="remarks"></a>Note
-  Questo controllo riconosce std::shared_pointer e tipi definiti dall'utente che possono comportarsi come puntatori condivisi. Le seguenti caratteristiche sono previste per puntatori condivisi definiti dall'utente:
-  di overload dereferenziare o operatori (pubblici e non è stato eliminato), accesso ai membri
-  costruttore di copia o operatore di assegnazione di copia (pubblici e non è stato eliminato).
-  distruttore pubblico che non viene eliminato né impostate come predefinito. Distruttori vuoti vengono conteggiati ancora come definito dall'utente.
-  L'azione di ripristino o la riassegnazione viene interpretato in modo più generico:
-  qualsiasi chiamata a un metodo non costante in un puntatore condiviso potenzialmente possibile reimpostare il puntatore.
-  qualsiasi chiamata a una funzione che accetta un riferimento a un puntatore di tipo condiviso non costante può potenzialmente reimpostare o riassegnare tale puntatore.

## <a name="example"></a>Esempio 
complicazione interfaccia necessaria

```cpp
bool unregister(std::shared_ptr<event> &e) // C26417, also C26415 SMART_PTR_NOT_NEEDED
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e))
        e = std::make_shared<event>(e->id());
    // ...
}
```

## <a name="example"></a>Esempio 
complicazione interfaccia inutili - semplificato

```cpp
bool unregister(const event *e)
{
    return e && events_.erase(e->id());
}

void renew(std::shared_ptr<event> &e)
{
    if (unregister(e.get()))
        e = std::make_shared<event>(e->id());
    // ...
}
```

