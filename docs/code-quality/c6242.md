---
title: C6242 | Documenti Microsoft
ms.custom: ''
ms.date: 11/04/2016
ms.technology:
- vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C6242
helpviewer_keywords:
- C6242
ms.assetid: 523d46ce-8370-434c-a752-2e3a18cca9a5
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: 4718246fdb87a52c0da787a23f438f8e8623a45d
ms.sourcegitcommit: 6a9d5bd75e50947659fd6c837111a6a547884e2a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/16/2018
---
# <a name="c6242"></a>C6242
avviso C6242: un salto da questo blocco try impone la rimozione locale. Comporta gravi problemi di prestazioni  
  
 Questo avviso indica che un'istruzione di salto fa sì che il flusso di controllo lasciare il blocco di un'istruzione try-finally diverso dal passaggio protetto.  
  
 Se si lascia il blocco di un'istruzione try-finally protetto altro rispetto a da passare all'ultima istruzione richiesto locale esecuzione di una rimozione. Per la quale in genere richiede circa 1000 di istruzioni del computer; è pertanto effetti negativo sulle prestazioni.  
  
 Utilizzare `_leave` uscire dal blocco protetto di un'istruzione try-finally.  
  
## <a name="example"></a>Esempio  
 Il codice seguente genera questo avviso:  
  
```  
#include <malloc.h>  
void DoSomething(char *p); // function can throw exception  
  
int f( )  
{  
   char *ptr = 0;  
   __try   
   {  
      ptr = (char*) malloc(10);  
      if ( !ptr )   
      {  
         return 0;   //Warning: 6242  
      }  
      DoSomething( ptr );  
   }  
   __finally   
   {  
      free( ptr );  
   }  
   return 1;  
}  
```  
  
 Per risolvere questo problema, utilizzare `__leave` come illustrato nel codice seguente:  
  
```  
#include <malloc.h>  
void DoSomething(char *p);   
int f()  
{  
   char *ptr = 0;  
   int retVal = 0;  
  
   __try   
   {  
      ptr = (char *) malloc(10);  
      if ( !ptr )  
      {  
         retVal = 0;  
         __leave;   //No warning  
      }  
      DoSomething( ptr );  
      retVal = 1;  
   }  
   __finally  
   {  
      free( ptr );  
   }  
  
   return retVal;  
}  
```  
  
 L'utilizzo di malloc e free hanno molti problemi in termini di perdite di memoria e le eccezioni. Per evitare questi tipi di perdite ed eccezione problemi inconsistenze, utilizzano i meccanismi forniti dalla libreria di modello Standard (STL) di C++. Questi includono [shared_ptr](/cpp/standard-library/shared-ptr-class), [unique_ptr](/cpp/standard-library/unique-ptr-class), e [vettore](/cpp/standard-library/vector). Per ulteriori informazioni, vedere [puntatori intelligenti](/cpp/cpp/smart-pointers-modern-cpp) e [della libreria Standard C++](/cpp/standard-library/cpp-standard-library-reference).  
  
## <a name="see-also"></a>Vedere anche  
 [Istruzione try-finally](/cpp/cpp/try-finally-statement)