---
title: 'CA1021: Evitare parametri out'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 579b04f26af972ac025b0bfc07bc8dc9eb636d12
ms.sourcegitcommit: 98421670ed0b8170aaa32d3d6f8681298f401a1d
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/18/2020
ms.locfileid: "81638023"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021: Evitare parametri out

|||
|-|-|
|TypeName|AvoidOutParameters|
|CheckId|CA1021|
|Category|Microsoft.Design|
|Modifica|Interruzione|

## <a name="cause"></a>Causa
Un metodo pubblico o protetto in `out` un tipo pubblico dispone di un parametro.

Per impostazione predefinita, questa regola esamina solo i tipi visibili esternamente, ma è [configurabile.](#configurability)

## <a name="rule-description"></a>Descrizione della regola
Il passaggio di `out` `ref`tipi per riferimento (using o ) richiede esperienza con i puntatori, la comprensione delle differenze tra tipi di valore e tipi di riferimento e la gestione di metodi con più valori restituiti. Inoltre, la `out` differenza `ref` tra e parametri non è ampiamente compresa.

Quando un tipo di riferimento viene passato "per riferimento", il metodo intende utilizzare il parametro per restituire un'istanza diversa dell'oggetto. Il passaggio di un tipo di riferimento per riferimento è noto anche come utilizzo di un puntatore doppio, di un puntatore a un puntatore o di un riferimento indiretto doppio. Utilizzando la convenzione di chiamata predefinita, ovvero passare "per valore", un parametro che accetta un tipo di riferimento riceve già un puntatore all'oggetto. Il puntatore, non l'oggetto a cui punta, viene passato per valore. Passa per valore significa che il metodo non può modificare il puntatore in modo che punti a una nuova istanza del tipo di riferimento. Tuttavia, può modificare il contenuto dell'oggetto a cui punta. Per la maggior parte delle applicazioni questo è sufficiente e produce il comportamento desiderato.

Se un metodo deve restituire un'istanza diversa, utilizzare il valore restituito del metodo per eseguire questa operazione. Vedere <xref:System.String?displayProperty=fullName> la classe per una varietà di metodi che operano sulle stringhe e restituiscono una nuova istanza di una stringa. Quando viene utilizzato questo modello, il chiamante deve decidere se l'oggetto originale viene mantenuto.

Sebbene i valori restituiti siano all'ordine `ref` del giorno e siano molto utilizzati, la corretta applicazione dei parametri e richiede `out` competenze di progettazione e codifica intermedie. Gli architetti di librerie che progettano per `out` `ref` un pubblico generale non devono aspettarsi che gli utenti acuissero a lavorare con o parametri.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni
Per correggere una violazione di questa regola causata da un tipo di valore, fare in modo che il metodo restituisca l'oggetto come valore restituito. Se il metodo deve restituire più valori, riprogettarlo per restituire una singola istanza di un oggetto che contiene i valori.

Per correggere una violazione di questa regola causata da un tipo di riferimento, assicurarsi che il comportamento desiderato consiste nel restituire una nuova istanza del riferimento. In caso affermativo, il metodo deve utilizzare il relativo valore restituito per eseguire questa operazione.

## <a name="when-to-suppress-warnings"></a>Quando eliminare gli avvisi
È sicuro escludere un avviso da questa regola. Tuttavia, questa progettazione potrebbe causare problemi di usabilità.

## <a name="configurability"></a>Configurabilità

Se si esegue questa regola dagli [analizzatori FxCop](install-fxcop-analyzers.md) (e non con l'analisi legacy), è possibile configurare le parti della codebase su cui eseguire questa regola, in base alla loro accessibilità. Ad esempio, per specificare che la regola deve essere eseguita solo sulla superficie dell'API non pubblica, aggiungere la seguente coppia chiave-valore a un file con estensione editorconfig nel progetto:

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

È possibile configurare questa opzione solo per questa regola, per tutte le regole o per tutte le regole di questa categoria (Progettazione). Per ulteriori informazioni, consultate [Configurare gli analizzatori FxCop.](configure-fxcop-analyzers.md)

## <a name="example"></a>Esempio
Nella libreria seguente vengono illustrate due implementazioni di una classe che genera risposte al feedback di un utente. La prima`BadRefAndOut`implementazione ( ) impone all'utente della libreria di gestire tre valori restituiti. La seconda`RedesignedRefAndOut`implementazione ( ) semplifica l'esperienza utente restituendo`ReplyData`un'istanza di una classe contenitore ( ) che gestisce i dati come una singola unità.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>Esempio
L'applicazione seguente illustra l'esperienza dell'utente. La chiamata alla libreria`UseTheSimplifiedClass` riprogettata ( metodo) è più semplice e le informazioni restituite dal metodo è facilmente gestibile. L'output dei due metodi è identico.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>Esempio
Nella libreria di esempio `ref` seguente viene illustrato l'utilizzo dei parametri per i tipi di riferimento e viene illustrato un modo migliore per implementare questa funzionalità.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>Esempio
L'applicazione seguente chiama ogni metodo nella libreria per illustrare il comportamento.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

Nell'esempio viene prodotto l'output seguente:

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>Metodi di modello Try

### <a name="description"></a>Descrizione
I metodi che implementano il <xref:System.Int32.TryParse%2A?displayProperty=fullName>modello di>**\<Prova qualcosa,** ad esempio , non generano questa violazione. Nell'esempio seguente viene illustrata una <xref:System.Int32.TryParse%2A?displayProperty=fullName> struttura (tipo di valore) che implementa il metodo .

### <a name="code"></a>Codice
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>Regole correlate
[CA1045: Non passare i tipi per riferimento](../code-quality/ca1045.md)
