---
title: 'CA1021: Evitare parametri out'
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- CA1021
- AvoidOutParameters
helpviewer_keywords:
- AvoidOutParameters
- CA1021
ms.assetid: 970f2304-842c-4fb7-9734-f3871da8d479
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 8e4a9c7109591ed93dbcbcb82b7b07ea1c94dfb0
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "88711404"
---
# <a name="ca1021-avoid-out-parameters"></a>CA1021: Evitare parametri out

|Elemento|valore|
|-|-|
|CheckId|CA1021|
|Category|Microsoft. Design|
|Modifica|Interruzione|

## <a name="cause"></a>Causa
Un metodo pubblico o protetto in un tipo pubblico ha un `out` parametro.

Per impostazione predefinita, questa regola esamina solo i tipi visibili esternamente, ma è [configurabile](#configurability).

## <a name="rule-description"></a>Descrizione della regola
Il passaggio di tipi per riferimento (tramite `out` o `ref` ) richiede l'utilizzo di puntatori, la comprensione della differenza tra tipi di valore e tipi di riferimento e la gestione di metodi con più valori restituiti. Inoltre, la differenza tra `out` i `ref` parametri e non è ampiamente riconosciuta.

Quando un tipo di riferimento viene passato "per riferimento", il metodo intende utilizzare il parametro per restituire un'istanza diversa dell'oggetto. Il passaggio di un tipo di riferimento per riferimento è noto anche come utilizzo di un puntatore doppio, puntatore a un puntatore o doppio riferimento indiretto. Utilizzando la convenzione di chiamata predefinita, che viene passata "per valore", un parametro che accetta un tipo di riferimento riceve già un puntatore all'oggetto. Il puntatore, non l'oggetto a cui fa riferimento, viene passato per valore. Passa per valore significa che il metodo non può modificare il puntatore in modo che punti a una nuova istanza del tipo di riferimento. Tuttavia, può modificare il contenuto dell'oggetto a cui punta. Per la maggior parte delle applicazioni questo è sufficiente e produce il comportamento desiderato.

Se un metodo deve restituire un'istanza diversa, usare il valore restituito del metodo per eseguire questa operazione. Vedere la <xref:System.String?displayProperty=fullName> classe per un'ampia gamma di metodi che operano sulle stringhe e restituiscono una nuova istanza di una stringa. Quando si utilizza questo modello, il chiamante deve decidere se l'oggetto originale viene conservato.

Sebbene i valori restituiti siano comuni e utilizzati molto spesso, l'applicazione corretta di `out` `ref` parametri e richiede competenze di progettazione e codifica intermedie. Gli architetti di librerie che progettano per i destinatari generali non dovrebbero prevedere agli utenti di usare i `out` `ref` parametri o.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni
Per correggere una violazione di questa regola causata da un tipo di valore, fare in modo che il metodo restituisca l'oggetto come valore restituito. Se il metodo deve restituire più valori, riprogettarlo per restituire una singola istanza di un oggetto che include i valori.

Per correggere una violazione di questa regola causata da un tipo riferimento, assicurarsi che il comportamento desiderato restituisca una nuova istanza del riferimento. In tal caso, il metodo deve usare il valore restituito per eseguire questa operazione.

## <a name="when-to-suppress-warnings"></a>Quando escludere gli avvisi
È possibile eliminare un avviso da questa regola in modo sicuro. Tuttavia, questo progetto potrebbe causare problemi di usabilità.

## <a name="configurability"></a>Configurabilità

È possibile configurare le parti della codebase su cui eseguire questa regola, in base all'accessibilità. Ad esempio, per specificare che la regola deve essere eseguita solo sulla superficie dell'API non pubblica, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
dotnet_code_quality.ca1021.api_surface = private, internal
```

È possibile configurare questa opzione solo per questa regola, per tutte le regole o per tutte le regole in questa categoria (progettazione). Per altre informazioni, vedere [configurare gli analizzatori di qualità del codice .NET](configure-fxcop-analyzers.md).

## <a name="example"></a>Esempio
La libreria seguente mostra due implementazioni di una classe che genera risposte ai commenti di un utente. La prima implementazione ( `BadRefAndOut` ) forza l'utente della libreria a gestire tre valori restituiti. La seconda implementazione ( `RedesignedRefAndOut` ) semplifica l'esperienza utente restituendo un'istanza di una classe contenitore ( `ReplyData` ) che gestisce i dati come una singola unità.

[!code-csharp[FxCop.Design.NoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_1.cs)]

## <a name="example"></a>Esempio
Nell'applicazione seguente viene illustrata l'esperienza dell'utente. La chiamata alla libreria riprogettata ( `UseTheSimplifiedClass` metodo) è più semplice e le informazioni restituite dal metodo sono facilmente gestibili. L'output dei due metodi è identico.

[!code-csharp[FxCop.Design.TestNoRefOrOut#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_2.cs)]

## <a name="example"></a>Esempio
Nella libreria di esempio seguente viene illustrata la modalità `ref` di utilizzo dei parametri per i tipi di riferimento e viene illustrato un modo migliore per implementare questa funzionalità.

[!code-csharp[FxCop.Design.RefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_3.cs)]

## <a name="example"></a>Esempio
L'applicazione seguente chiama ogni metodo nella libreria per illustrare il comportamento.

[!code-csharp[FxCop.Design.TestRefByRefNo#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_4.cs)]

Nell'esempio viene prodotto l'output seguente:

```txt
Changing pointer - passed by value:
12345
12345
Changing pointer - passed by reference:
12345
12345 ABCDE
Passing by return value:
12345 ABCDE
```

## <a name="try-pattern-methods"></a>Metodi pattern try

### <a name="description"></a>Descrizione
I metodi che implementano il modello ** \<Something> try** , ad esempio <xref:System.Int32.TryParse%2A?displayProperty=fullName> , non generano questa violazione. Nell'esempio seguente viene illustrata una struttura (tipo di valore) che implementa il <xref:System.Int32.TryParse%2A?displayProperty=fullName> metodo.

### <a name="code"></a>Codice
[!code-csharp[FxCop.Design.TryPattern#1](../code-quality/codesnippet/CSharp/ca1021-avoid-out-parameters_5.cs)]

## <a name="related-rules"></a>Regole correlate
[CA1045: Non passare i tipi per riferimento](../code-quality/ca1045.md)
