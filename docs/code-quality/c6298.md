---
title: C6298
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- C6298
helpviewer_keywords:
- C6298
ms.assetid: 986dc8e7-8596-4223-a66f-8616357d4399
author: corob-msft
ms.author: corob
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 625bc5b02a1b569f670b77153947f94c14adf4cf
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/15/2020
ms.locfileid: "77267060"
---
# <a name="c6298"></a>C6298
avviso C6298: utilizzo di una stringa di sola lettura \<puntatore > come argomento stringa scrivibile: verrà eseguito un tentativo di scrittura nella memoria statica in sola lettura e la causa arresti anomali casuali

 Questo avviso indica l'uso di una stringa costante come argomento di una funzione che potrebbe modificare il contenuto di tale stringa. Poiché il compilatore alloca stringhe costanti in una memoria statica di sola lettura, qualsiasi tentativo di modificarlo causa violazioni di accesso e arresti anomali casuali.

 Questa operazione può essere evitata archiviando la stringa costante in una matrice locale e quindi usando la matrice come argomento della funzione.

## <a name="example"></a>Esempio
 Il codice di esempio seguente genera questo avviso:

```cpp
#include <windows.h>
#include <stdio.h>

void f()
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );
    ZeroMemory( &pi, sizeof( pi ) );
    if( !CreateProcess(NULL,
                      "\"c:\\Windows\\system32\\calc.exe\"",
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi ) )
    {
        puts( "CreateProcess failed." );
        return;
    }

    // Wait until child process exits.
    WaitForSingleObject( pi.hProcess, INFINITE );

    // Close process and thread handles.
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}
```

 Per correggere il problema, usare il codice di esempio seguente:

```cpp
#include <windows.h>
#include <stdio.h>

void f( )
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    char szCmdLine[] = "\"c:\\Windows\\system32\\calc.exe\"";
    ZeroMemory( &si, sizeof( si ) );
    si.cb = sizeof( si );
    ZeroMemory( &pi, sizeof( pi ) );

    if( !CreateProcess(NULL,
                      szCmdLine,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &si,
                      &pi ) )
    {
        puts( "CreateProcess failed." );
        return;
    }

    // Wait until child process exits.
    WaitForSingleObject( pi.hProcess, INFINITE );

    // Close process and thread handles.
    CloseHandle( pi.hProcess );
    CloseHandle( pi.hThread );
}
```
