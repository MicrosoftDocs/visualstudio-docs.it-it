---
title: C26430
ms.date: 11/15/2017
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26430
helpviewer_keywords:
- C26430
ms.assetid: 3dca2626-8102-4eed-8ff3-73eb3d5c328c
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: bbeb8f42b728dd65fffc983b7143e8be107d50cf
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/19/2018
---
# <a name="c26430-testonallpaths"></a>C26430 TEST_ON_ALL_PATHS
"Simbolo non è stato testato dell'invalidità su tutti i percorsi."

**Linee guida dei componenti di base di C++**: F.23: utilizzare un not_null<T> per indicare che "null" non è un valore valido

Se il codice controlla mai dell'invalidità di variabili puntatore dovrebbe eseguire questa operazione in modo coerente e convalidare i puntatori per tutti i percorsi. A volte overaggressive cercano dell'invalidità è ancora migliore possibilità di un arresto anomalo del disco rigido in uno dei rami complessi. Idealmente tale codice deve essere sottoposto a refactoring meno complesso (suddividendo in funzioni più) e si basano su indicatori come gsl::not_null (vedere le linee guida della libreria di supporto) per isolare le parti dell'algoritmo che può fare ipotesi sicuro sui valori di puntatore valido. La regola TEST_ON_ALL_PATHS consente di individuare i punti in cui i controlli dell'invalidità sono incoerenti (presupposti, pertanto potrebbe essere necessario esaminare) o i bug effettivi in cui il valore null potenziale può ignorare dell'invalidità controllare alcuni percorsi del codice.

## <a name="remarks"></a>Note
 -  Questa regola prevede che codice Dereferenzia una variabile di puntatore in modo che il controllo dell'invalidità (o l'applicazione di valore non null) potrebbe essere giustificato. Se non si verifica alcuna risoluzione, la regola viene sospesa.
-  Gestisce solo i puntatori normali (o i relativi alias) e l'implementazione corrente non rileva i puntatori intelligenti, anche se i controlli dell'invalidità sono applicabili per i puntatori intelligenti.
-  Una variabile è contrassegnata come controllata dell'invalidità quando viene utilizzata nei contesti seguenti:
-  come un'espressione di simboli in una condizione di ramo, ad esempio, "se (p) {…}";
-  operazioni non bit per bit logiche;
-  operazioni di confronto in cui un operando è un'espressione costante che restituisce zero.
-  La regola non dispone di rilevamento del flusso di dati complete e possono produrre risultati non corretti nei casi in cui vengono utilizzati i controlli indiretti (ad esempio, quando variabile intermedia contiene un valore null e successivamente utilizzato nel confronto).
-  Quando viene assegnato il valore di puntatore, si presuppone che i controlli dell'invalidità implicita:
-  un'allocazione eseguita con generazione operatore new.
-  un puntatore ottenuto dal tipo contrassegnato con gsl::not_null.
## <a name="example"></a>Esempio
test incoerente, viene visualizzato un errore della logica

```cpp
void merge_states(const state *left, const state *right) // C26430
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (!left && !right)                            // Logic error!
            discard(left, right);
    }
}
```

## <a name="example"></a>Esempio
test incoerente rivela errore logica - corretto

```cpp
void merge_states(gsl::not_null<const state *> left, gsl::not_null<const state *> right)
{
    if (*left && *right)
        converge(left, right);
    else
    {
        // ...
        if (*left && *right)
            discard(left, right);
    }
}
```
