---
title: Regole di sicurezza
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security rules
- managed code analysis rules, security rules
- rules, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 2eb2356628099246aa010c0332f473955a3e976d
ms.sourcegitcommit: 566144d59c376474c09bbb55164c01d70f4b621c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/19/2020
ms.locfileid: "90807924"
---
# <a name="security-rules"></a>Regole di sicurezza

Le regole di sicurezza supportano librerie e applicazioni più sicure. Queste regole consentono di evitare errori di sicurezza nel programma. Se si disabilita una di queste regole, è necessario contrassegnare chiaramente il motivo nel codice e informare il responsabile della sicurezza designato per il progetto di sviluppo.

## <a name="in-this-section"></a>Contenuto della sezione

|Regola|Descrizione|
|----------|-----------------|
|[CA2100: Controllare la vulnerabilità della sicurezza nelle query SQL](../code-quality/ca2100.md)|Un metodo imposta la proprietà System.Data.IDbCommand.CommandText usando una stringa compilata da un argomento stringa nel metodo. La regola presuppone che l'argomento stringa contenga l'input dell'utente. Una stringa di comando SQL compilata da un input dell'utente è vulnerabile agli attacchi intrusivi nel codice SQL,|
|[CA2109: Controllare i gestori di eventi visibili](../code-quality/ca2109.md)|È stato rilevato un metodo di gestione eventi pubblico o protetto. I metodi di gestione eventi non devono essere esposti se non assolutamente necessario.|
|[CA2119: Impostare come sealed i metodi che soddisfano interfacce private](../code-quality/ca2119.md)|Un tipo pubblico ereditabile fornisce un'implementazione di metodo sottoponibile a override di un'interfaccia interna (Friend in Visual Basic). Per correggere una violazione di questa regola, impedire che venga eseguito l'override del metodo esternamente all'assembly.|
|[CA2153: Evitare la gestione delle eccezioni stato danneggiato](../code-quality/ca2153.md)|Le[eccezioni in stato danneggiato (CSE, Corrupted State Exception)](/archive/msdn-magazine/2009/february/clr-inside-out-handling-corrupted-state-exceptions) indicano che sono presenti danni nella memoria del processo. Se si prova a intercettare tali eccezioni, invece di lasciare che il processo venga arrestato in modo anomalo, può portare a vulnerabilità di sicurezza nel caso in cui un utente malintenzionato riesca a inserire un exploit nell'area della memoria danneggiata.|
|[CA2300: Non usare il deserializzatore non sicuro BinaryFormatter](../code-quality/ca2300.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2301: Non chiamare BinaryFormatter.Deserialize senza aver prima impostato BinaryFormatter.Binder](../code-quality/ca2301.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2302: Assicurarsi che BinaryFormatter.Binder sia impostato prima di chiamare BinaryFormatter.Deserialize](../code-quality/ca2302.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2305: Non usare il deserializzatore non sicuro LosFormatter](../code-quality/ca2305.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2310: Non usare il deserializzatore non sicuro NetDataContractSerializer](../code-quality/ca2310.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2311: Non eseguire la deserializzazione senza aver prima impostato NetDataContractSerializer.Binder](../code-quality/ca2311.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2312: Assicurarsi di impostare NetDataContractSerializer.Binder prima della deserializzazione](../code-quality/ca2312.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2315: Non usare il deserializzatore non sicuro ObjectStateFormatter](../code-quality/ca2315.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2321: Non eseguire la deserializzazione con JavaScriptSerializer usando un oggetto SimpleTypeResolver](../code-quality/ca2321.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2322: Verificare che l'oggetto JavaScriptSerializer non sia inizializzato con SimpleTypeResolver prima di eseguire la deserializzazione](../code-quality/ca2322.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2326: Non usare valori di TypeNameHandling diversi da None](../code-quality/ca2326.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2327: Non usare oggetti JsonSerializerSettings non sicuri](../code-quality/ca2327.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2328: Assicurarsi che gli oggetti JsonSerializerSettings siano sicuri](../code-quality/ca2328.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2329: Non eseguire la deserializzazione con JsonSerializer usando una configurazione non sicura](../code-quality/ca2329.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2330: Assicurarsi che JsonSerializer abbia una configurazione sicura durante la deserializzazione](../code-quality/ca2330.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2350: Verificare che l'input di DataTable.ReadXml() sia attendibile](ca2350.md)|Quando si deserializza un oggetto <xref:System.Data.DataTable> con un input non attendibile, un utente malintenzionato può creare input dannosi per eseguire un attacco Denial of Service. Potrebbero esserci vulnerabilità di esecuzione del codice remoto sconosciute.|
|[CA2351: Verificare che l'input di DataSet.ReadXml() sia attendibile](ca2351.md)|Quando si deserializza un oggetto <xref:System.Data.DataSet> con un input non attendibile, un utente malintenzionato può creare input dannosi per eseguire un attacco Denial of Service. Potrebbero esserci vulnerabilità di esecuzione del codice remoto sconosciute.|
|[CA2352: Un elemento DataSet o DataTable non sicuro nel tipo serializzabile può essere vulnerabile agli attacchi di esecuzione di codice remoto](ca2352.md)|Una classe o uno struct contrassegnato con <xref:System.SerializableAttribute> contiene una <xref:System.Data.DataSet> proprietà o un campo o <xref:System.Data.DataTable> e non dispone di un oggetto <xref:System.CodeDom.Compiler.GeneratedCodeAttribute> .|
|[CA2353: Elemento DataSet o DataTable non sicuro in un tipo serializzabile](ca2353.md)|Una classe o uno struct contrassegnato con un attributo di serializzazione XML o un attributo di contratto dati contiene un campo o una <xref:System.Data.DataSet> <xref:System.Data.DataTable> Proprietà.|
|[CA2354: Un elemento DataSet o DataTable non sicuro nel grafico di oggetti deserializzato può essere vulnerabile agli attacchi di esecuzione di codice remoto](ca2354.md)|La deserializzazione con un <xref:System.Runtime.Serialization.IFormatter?displayProperty=nameWithType> oggetto serializzato e l'oggetto grafico del tipo con cast possono includere un oggetto <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2355: Elemento DataSet o DataTable non sicuro nel grafico di oggetti deserializzato](ca2355.md)|Deserializzazione quando l'oggetto grafico del tipo sottoposto a cast o specificato può includere <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2356: DataSet o DataTable non sicuro nell'oggetto grafico deserializzato Web](ca2356.md)|Un metodo con un oggetto <xref:System.Web.Services.WebMethodAttribute?displayProperty=nameWithType> o <xref:System.ServiceModel.OperationContractAttribute?displayProperty=nameWithType> ha un parametro che può fare riferimento a <xref:System.Data.DataSet> o <xref:System.Data.DataTable> .|
|[CA2361: Assicurarsi che la classe generata automaticamente che contiene DataSet.ReadXml() non venga usata con dati non attendibili](ca2361.md)|Quando si deserializza un oggetto <xref:System.Data.DataSet> con un input non attendibile, un utente malintenzionato può creare input dannosi per eseguire un attacco Denial of Service. Potrebbero esserci vulnerabilità di esecuzione del codice remoto sconosciute.|
|[CA2362: L'oggetto DataSet o DataTable non sicuro nel tipo serializzabile generato automaticamente può essere vulnerabile ad attacchi di tipo esecuzione di codice remoto](ca2362.md)|Quando si deserializza un input non attendibile con <xref:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter> e l'oggetto grafico deserializzato contiene <xref:System.Data.DataSet> o <xref:System.Data.DataTable> , un utente malintenzionato può creare un payload dannoso per eseguire un attacco di esecuzione del codice remoto.|
|[CA3001: Esaminare il codice per verificare la presenza di vulnerabilità di tipo SQL injection](../code-quality/ca3001.md)|Quando si utilizzano comandi SQL e input non attendibili, tenere presenti gli attacchi SQL injection. Un attacco SQL injection può eseguire comandi SQL dannosi, compromettendo la sicurezza e l'integrità dell'applicazione.|
|[CA3002: Esaminare il codice per verificare la presenza di vulnerabilità di tipo XSS](../code-quality/ca3002.md)|Quando si utilizza un input non attendibile da richieste Web, tenere presente gli attacchi XSS (cross-site scripting). Un attacco XSS inserisce input non attendibile nell'output HTML non elaborato, consentendo all'autore dell'attacco di eseguire script dannosi o modificare il contenuto nella pagina Web.|
|[CA3003: Esaminare il codice per verificare la presenza di vulnerabilità di tipo file path injection](../code-quality/ca3003.md)|Quando si utilizza un input non attendibile da richieste Web, tenere presente l'utilizzo dell'input controllato dall'utente quando si specificano i percorsi dei file.|
|[CA3004: Esaminare il codice per verificare la presenza di vulnerabilità di tipo diffusione di informazioni](../code-quality/ca3004.md)|La divulgazione delle informazioni sulle eccezioni consente agli utenti malintenzionati di comprendere le caratteristiche interne dell'applicazione, che possono aiutare gli utenti malintenzionati a trovare altre vulnerabilità da sfruttare.|
|[CA3006: Esaminare il codice per verificare la presenza di vulnerabilità di tipo process command injection](../code-quality/ca3006.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di inserimento dei comandi. Un attacco injection comando può eseguire comandi dannosi sul sistema operativo sottostante, compromettendo la sicurezza e l'integrità del server.|
|[CA3007: Esaminare il codice per verificare la presenza di vulnerabilità di tipo reindirizzamento aperto](../code-quality/ca3007.md)|Quando si lavora con un input non attendibile, tenere presenti le vulnerabilità di reindirizzamento aperte. Un utente malintenzionato può sfruttare una vulnerabilità di reindirizzamento aperto per usare il sito Web per dare l'impressione di un URL legittimo, ma reindirizzare un visitatore ignaro a un phishing o ad altre pagine Web dannose.|
|[CA3008: Esaminare il codice per verificare la presenza di vulnerabilità di tipo XPath injection](../code-quality/ca3008.md)|Quando si lavora con un input non attendibile, tenere presenti gli attacchi XPath injection. La costruzione di query XPath tramite input non attendibile può consentire a un utente malintenzionato di manipolare in modo dannoso la query per restituire un risultato imprevisto ed eventualmente divulgare il contenuto dell'XML sottoposto a query.|
|[CA3009: Esaminare il codice per verificare la presenza di vulnerabilità di tipo XML injection](../code-quality/ca3009.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi intrusivi in XML.|
|[CA3010: Esaminare il codice per verificare la presenza di vulnerabilità di tipo XAML injection](../code-quality/ca3010.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di inserimento di XAML. XAML è un linguaggio di markup che rappresenta direttamente la creazione di istanze di oggetti e la relativa esecuzione. Ciò significa che gli elementi creati in XAML possono interagire con le risorse di sistema, ad esempio l'accesso alla rete e file system i/o.|
|[CA3011: Esaminare il codice per verificare la presenza di vulnerabilità di tipo DLL injection](../code-quality/ca3011.md)|Quando si utilizza un input non attendibile, tenere presente il caricamento di codice non attendibile. Se l'applicazione Web carica codice non attendibile, un utente malintenzionato potrebbe essere in grado di inserire dll dannose nel processo ed eseguire codice dannoso.|
|[CA3012: Esaminare il codice per verificare la presenza di vulnerabilità di tipo regex injection](../code-quality/ca3012.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di attacchi Regex. Un utente malintenzionato può utilizzare l'inserimento Regex per modificare in modo dannoso un'espressione regolare, per fare in modo che l'espressione regolare corrisponda a risultati imprevisti oppure per fare in modo che la regex utilizzi una CPU eccessiva con conseguente attacco Denial of Service.|
|[CA3061: Non aggiungere lo schema in base all'URL](../code-quality/ca3061.md)|Non usare l'overload unsafe del metodo Add perché potrebbe causare riferimenti esterni pericolosi.|
|[CA3075: Elaborazione DTD non protetta](../code-quality/ca3075.md)|Se si usano istanze di DTDProcessing non protette o si fa riferimento a origini di entità esterne, il parser può accettare un input non attendibile e divulgare informazioni riservate a utenti malintenzionati.|
|[CA3076: Esecuzione di script XSLT non protetta](../code-quality/ca3076.md)|Se si esegue Extensible Stylesheet Language Transformations (XSLT) in applicazioni .NET in modo non protetto, il processore può risolvere i riferimenti URI non attendibili che potrebbero divulgare informazioni riservate a utenti malintenzionati, causando attacchi Denial of Service e tra siti.|
|[CA3077: Elaborazione non sicura in progettazione API, documenti XML e lettori di testo XML](../code-quality/ca3077.md)|Quando si progetta un'API derivata da XMLDocument e XMLTextReader, tenere presente DtdProcessing. Se si usano istanze di DTDProcessing non protette per fare riferimento o risolvere origini di entità esterne oppure per impostare valori non protetti nel codice XML, si può causare la divulgazione di informazioni.|
|[CA3147: Contrassegnare i gestori di verbi con ValidateAntiForgeryToken](../code-quality/ca3147.md)|Quando si progetta un controller MVC ASP.NET, tenere presenti gli attacchi di richiesta intersito falsa. Un attacco di richiesta intersito falsificazione può inviare richieste dannose da un utente autenticato al controller MVC ASP.NET.|
|[CA5350: Non usare algoritmi di crittografia vulnerabili](../code-quality/ca5350.md)|Oggi si usano algoritmi di crittografia e funzioni hash deboli per diversi motivi, ma non dovrebbero essere usati per garantire la riservatezza o l'integrità dei dati che proteggono. Questa regola si attiva quando vengono rilevati algoritmi TripleDES, SHA1 o RIPEMD160 nel codice.|
|[CA5351:: non usare algoritmi di crittografia interrotti](../code-quality/ca5351.md)|Gli algoritmi di crittografia violati non sono considerati sicuri e il loro uso è fortemente sconsigliato. Questa regola si attiva quando nel codice vengono rilevati l'algoritmo hash MD5 oppure gli algoritmi di crittografia DES o RC2.|
|[CA5358: Non usare modalità crittografia non sicure](../code-quality/ca5358.md)|Non usare modalità crittografia non sicure|
|[CA5359: Non disabilitare la convalida del certificato](../code-quality/ca5359.md)|Un certificato può essere utile per autenticare l'identità del server. I client devono convalidare il certificato del server per garantire che le richieste vengano inviate al server desiderato. Se il ServerCertificateValidationCallback restituisce sempre `true` , qualsiasi certificato passerà la convalida.|
|[CA5360: Non chiamare metodi pericolosi durante la deserializzazione](../code-quality/ca5360.md)|La deserializzazione non sicura è una vulnerabilità che si verifica quando i dati non attendibili vengono usati per abusare la logica di un'applicazione, infliggendo un attacco Denial of Service (DoS) o persino eseguendo codice arbitrario al momento della deserializzazione. Spesso gli utenti malintenzionati possono usare queste funzionalità di deserializzazione quando l'applicazione deserializza dati non attendibili sotto il proprio controllo. In particolare, richiamare metodi pericolosi nel processo di deserializzazione. Gli attacchi di deserializzazione non sicuri riusciti potrebbero consentire a un utente malintenzionato di eseguire attacchi come attacchi DoS, bypass di autenticazione ed esecuzione di codice in modalità remota.|
|[CA5361: non disabilitare l'uso di crittografia avanzata SChannel](../code-quality/ca5361.md)|`Switch.System.Net.DontEnableSchUseStrongCrypto`L'impostazione di per `true` indebolisce la crittografia utilizzata nelle connessioni di Transport Layer Security in uscita (TLS). La crittografia più debole può compromettere la riservatezza delle comunicazioni tra l'applicazione e il server, semplificando l'intercettazione dei dati sensibili da parte degli utenti malintenzionati.|
|[CA5362: Ciclo di riferimento potenziale nel grafico di oggetti deserializzato](../code-quality/ca5362.md)|In caso di deserializzazione di dati non attendibili, qualsiasi codice che elabora l'oggetto grafico deserializzato deve gestire i cicli di riferimento senza passare a cicli infiniti. Sono inclusi sia il codice che fa parte di un callback di deserializzazione che il codice che elabora l'oggetto grafico al termine della deserializzazione. In caso contrario, un utente malintenzionato potrebbe eseguire un attacco Denial of Service con dati dannosi contenenti un ciclo di riferimento.|
|[CA5363: Non disabilitare la convalida delle richieste](../code-quality/ca5363.md)|La convalida delle richieste è una funzionalità di ASP.NET che esamina le richieste HTTP e determina se contengono contenuti potenzialmente pericolosi che possono causare attacchi injection, incluso lo scripting tra siti.|
|[CA5364: Non usare protocolli di sicurezza deprecati](../code-quality/ca5364.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni precedenti del protocollo TLS sono meno sicure di TLS 1,2 e TLS 1,3 ed è più probabile che abbiano nuove vulnerabilità. Evitare le versioni precedenti del protocollo per ridurre al minimo i rischi.|
|[CA5365: Non disabilitare il controllo delle intestazioni HTTP](../code-quality/ca5365.md)|Il controllo dell'intestazione HTTP consente la codifica dei caratteri di ritorno a capo e di nuova riga, ovvero e \n, presenti nelle intestazioni di risposta. Questa codifica può contribuire a evitare attacchi intrusivi che sfruttano un'applicazione che restituisce dati non attendibili contenuti nell'intestazione.|
|[CA5366: Usa XmlReader per il codice XML di lettura del set di dati](../code-quality/ca5366.md)|L'utilizzo <xref:System.Data.DataSet> di un oggetto per la lettura di dati XML con dati non attendibili può caricare riferimenti esterni pericolosi, che devono essere limitati utilizzando un <xref:System.Xml.XmlReader> con un resolver sicuro o con l'elaborazione DTD disabilitata.|
|[CA5367: Non serializzare i tipi con campi puntatore](../code-quality/ca5367.md)|Questa regola consente di controllare se è presente una classe serializzabile con un campo o una proprietà del puntatore. I membri che non possono essere serializzati possono essere un puntatore, ad esempio i membri statici o i campi contrassegnati con <xref:System.NonSerializedAttribute> .|
|[CA5368: Impostare ViewStateUserKey per classi derivate da Page](../code-quality/ca5368.md)|L'impostazione della proprietà consente di <xref:System.Web.UI.Page.ViewStateUserKey> impedire gli attacchi sull'applicazione consentendo di assegnare un identificatore alla variabile dello stato di visualizzazione per i singoli utenti, in modo che gli utenti malintenzionati non possano utilizzare la variabile per generare un attacco. In caso contrario, saranno presenti vulnerabilità per la richiesta tra siti falsa.|
|[CA5369: Usa XmlReader per la deserializzazione](../code-quality/ca5369.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi, che devono essere limitati utilizzando un oggetto XmlReader con un resolver sicuro oppure con la DTD e l'elaborazione dello schema inline XML disabilitata.|
|[CA5370: Usare XmlReader per la convalida del lettore](../code-quality/ca5370.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi. Questo caricamento pericoloso può essere limitato utilizzando un oggetto XmlReader con un resolver sicuro oppure con la DTD e l'elaborazione dello schema inline XML disabilitata.|
|[CA5371: Usa XmlReader per la lettura dello schema](../code-quality/ca5371.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi. L'utilizzo di un oggetto XmlReader con un resolver protetto o con la DTD e l'elaborazione dello schema inline XML disabilitato limita questa operazione.|
|[CA5372: Usa XmlReader per XPathDocument](../code-quality/ca5372.md)|L'elaborazione di dati XML da dati non attendibili può caricare riferimenti esterni pericolosi, che possono essere limitati utilizzando un XmlReader con un resolver sicuro o con l'elaborazione DTD disabilitata.|
|[CA5373: Non usare la funzione di derivazione di chiave obsoleta](../code-quality/ca5373.md)|Questa regola rileva la chiamata dei metodi di derivazione della chiave debole <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> e `Rfc2898DeriveBytes.CryptDeriveKey` . <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> è stato usato un algoritmo PBKDF1 vulnerabile.|
|[CA5374: Non usare XslTransform](../code-quality/ca5374.md)|Questa regola consente di controllare se <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> viene creata un'istanza nel codice. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> è ora obsoleto e non deve essere usato.|
|[CA5375: Non usare la firma di accesso condiviso dell'account](../code-quality/ca5375.md)|Una firma di accesso condiviso dell'account può delegare l'accesso alle operazioni di lettura, scrittura ed eliminazione su contenitori BLOB, tabelle, code e condivisioni file che non sono consentiti con una firma di accesso condiviso del servizio. Tuttavia, non supporta i criteri a livello di contenitore e ha meno flessibilità e controllo sulle autorizzazioni concesse. Una volta che gli utenti malintenzionati lo ottengono, l'account di archiviazione verrà compromesso con facilità.|
|[CA5376: Usa SharedAccessProtocol.HttpsOnly](../code-quality/ca5376.md)|SAS è dati sensibili che non possono essere trasportati in testo normale su HTTP.|
|[CA5377: Usa criteri di accesso a livello di contenitore](../code-quality/ca5377.md)|I criteri di accesso a livello di contenitore possono essere modificati o revocati in qualsiasi momento. Offre maggiore flessibilità e controllo sulle autorizzazioni concesse.|
|[CA5378: Non disabilitare ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Impostando `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` su `true` , le connessioni di Windows Communication Framework (WCF) Transport Layer Security (TLS) a usano TLS 1,0. La versione di TLS sarà deprecata.|
|[CA5379: Non usare l'algoritmo della funzione di derivazione di chiave vulnerabile](../code-quality/ca5379.md)|<xref:System.Security.Cryptography.Rfc2898DeriveBytes>Per impostazione predefinita, la classe usa l' <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algoritmo. È necessario specificare l'algoritmo hash da usare in alcuni overload del costruttore con <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> o versione successiva. Si noti <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> che la proprietà ha solo una `get` funzione di accesso e non ha un `overriden` modificatore.|
|[CA5380: Non aggiungere certificati all'archivio radice](../code-quality/ca5380.md)|Questa regola rileva il codice che aggiunge un certificato nell'archivio certificati delle autorità di certificazione radice attendibili. Per impostazione predefinita, l'archivio certificati delle autorità di certificazione radice attendibili è configurato con un set di CA pubbliche che soddisfa i requisiti del programma Microsoft Root Certificate.|
|[CA5381: Assicurarsi che i certificati non vengano aggiunti all'archivio radice](../code-quality/ca5381.md)|Questa regola rileva il codice che potenzialmente aggiunge un certificato all'archivio certificati delle autorità di certificazione radice attendibili. Per impostazione predefinita, l'archivio certificati delle autorità di certificazione radice attendibili è configurato con un set di autorità di certificazione pubbliche (CAs) che soddisfano i requisiti del programma Microsoft Root Certificate.|
|[CA5382: Usa cookie protetti in ASP.NET Core](../code-quality/ca5382.md)|Le applicazioni disponibili tramite HTTPS devono usare cookie protetti, che indicano al browser che il cookie deve essere trasmesso solo usando Transport Layer Security (TLS).|
|[CA5383: Assicura l'uso di cookie protetti in ASP.NET Core](../code-quality/ca5383.md)|Le applicazioni disponibili tramite HTTPS devono usare cookie protetti, che indicano al browser che il cookie deve essere trasmesso solo usando Transport Layer Security (TLS).|
|[CA5384: Non usare l'algoritmo di firma digitale (DSA)](../code-quality/ca5384.md)|DSA è un algoritmo di crittografia asimmetrica debole.|
|[CA5385: Usa l'algoritmo RSA (Rivest-Shamir-Adleman) con dimensione di chiave sufficiente](../code-quality/ca5385.md)|Una chiave RSA inferiore a 2048 bit è più vulnerabile agli attacchi di forza bruta.|
|[CA5386: Evitare di impostare il valore SecurityProtocolType come hardcoded](../code-quality/ca5386.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni del protocollo TLS 1,0 e TLS 1,1 sono deprecate, mentre TLS 1,2 e TLS 1,3 sono correnti. In futuro, è possibile che TLS 1,2 e TLS 1,3 siano deprecati. Per assicurarsi che l'applicazione rimanga protetta, evitare di impostare come hardcoded una versione del protocollo e specificare come destinazione almeno .NET Framework v 4.7.1.|
|[CA5387: Non usare la funzione di derivazione di chiave vulnerabile con un numero di iterazioni insufficiente](../code-quality/ca5387.md)|Questa regola consente di controllare se una chiave crittografica è stata generata da <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un numero di iterazioni inferiore a 100.000. Un numero di iterazioni superiore può contribuire a mitigare gli attacchi del dizionario che tentano di indovinare la chiave crittografica generata.|
|[CA5388: Assicurare un numero di iterazioni sufficiente quando si usa la funzione di derivazione di chiave vulnerabile](../code-quality/ca5388.md)|Questa regola consente di controllare se una chiave crittografica è stata generata da <xref:System.Security.Cryptography.Rfc2898DeriveBytes> con un numero di iterazioni inferiore a 100.000. Un numero di iterazioni superiore può contribuire a mitigare gli attacchi del dizionario che tentano di indovinare la chiave crittografica generata.|
|[CA5389: Non aggiungere il percorso dell'elemento di archiviazione al percorso del file system di destinazione](../code-quality/ca5389.md)|Il percorso del file può essere relativo e può comportare l'accesso file system al di fuori del percorso di destinazione file system previsto, causando modifiche di configurazione dannose e l'esecuzione di codice in modalità remota tramite la tecnica Lay-and-wait.|
|[CA5390: Non impostare la chiave di crittografia come hardcoded](../code-quality/ca5390.md)|Affinché un algoritmo simmetrico abbia esito positivo, la chiave privata deve essere nota solo al mittente e al ricevitore. Quando una chiave è hardcoded, viene individuata facilmente. Anche con i file binari compilati, è facile per l'estrazione da parte di utenti malintenzionati. Una volta compromessa la chiave privata, il testo crittografato può essere decrittografato direttamente e non è più protetto.|
|[CA5391: Usare token antifalsificazione nei controller MVC ASP.NET Core](../code-quality/ca5391.md)|La gestione `POST` `PUT` di una richiesta,, `PATCH` o `DELETE` senza convalidare un token antifalsificazione può essere vulnerabile agli attacchi di richiesta intersito falsa. Un attacco di richiesta intersito falsificazione può inviare richieste dannose da un utente autenticato al controller ASP.NET Core MVC.|
|[CA5392: Usare l'attributo DefaultDllImportSearchPaths per i P/Invoke](../code-quality/ca5392.md)|Per impostazione predefinita, le funzioni P/Invoke che usano il <xref:System.Runtime.InteropServices.DllImportAttribute> Probe di un numero di directory, inclusa la directory di lavoro corrente per il caricamento della libreria. Questo può costituire un problema di sicurezza per determinate applicazioni, causando il Hijack della DLL.|
|[CA5393: Non usare il valore DllImportSearchPath non sicuro](../code-quality/ca5393.md)|Potrebbe essere presente una DLL dannosa nelle directory di ricerca DLL e nelle directory di assembly predefinite. In alternativa, a seconda della posizione in cui viene eseguita l'applicazione, potrebbe essere presente una DLL dannosa nella directory dell'applicazione.|
|[CA5394: Non usare la casualità non sicura](../code-quality/ca5394.md)|L'uso di un generatore di numeri pseudo-casuali a crittografia debole può consentire a un utente malintenzionato di stimare il valore che deve essere generato con distinzione di sicurezza.|
|[CA5395: Attributo HttpVerb mancante per i metodi di azione](../code-quality/ca5395.md)|Tutti i metodi di azione che creano, modificano, eliminano o modificano in altro modo i dati devono essere protetti con l'attributo antifalsificazione da attacchi di richiesta intersito falsa. L'esecuzione di un'operazione GET deve essere un'operazione sicura che non ha effetti collaterali e non modifica i dati persistenti.|
|[CA5396: Impostare HttpOnly su true per HttpCookie](../code-quality/ca5396.md)|Come misura di difesa in profondità, assicurarsi che i cookie HTTP sensibili alla sicurezza siano contrassegnati come HttpOnly. Ciò indica che i Web browser non consentono l'accesso ai cookie da parte degli script. Gli script dannosi inseriti sono un metodo comune per il furto dei cookie.|
|[CA5397: Non usare valori SslProtocols deprecati](../code-quality/ca5397.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni precedenti del protocollo TLS sono meno sicure di TLS 1,2 e TLS 1,3 ed è più probabile che abbiano nuove vulnerabilità. Evitare le versioni precedenti del protocollo per ridurre al minimo i rischi.|
|[CA5398: Evitare valori SslProtocols hardcoded](../code-quality/ca5398.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni del protocollo TLS 1,0 e TLS 1,1 sono deprecate, mentre TLS 1,2 e TLS 1,3 sono correnti. In futuro, è possibile che TLS 1,2 e TLS 1,3 siano deprecati. Per assicurarsi che l'applicazione rimanga protetta, evitare di impostare come hardcoded una versione del protocollo.|
|[CA5399: Disabilitare definitivamente il controllo dell'elenco di revoche di certificati di HttpClient](../code-quality/ca5399.md)|Un certificato revocato non è più attendibile. Potrebbe essere utilizzato da utenti malintenzionati che passano alcuni dati dannosi o rubando dati sensibili nella comunicazione HTTPS.|
|[CA5400: Assicurarsi che il controllo dell'elenco di revoche di certificati di HttpClient non sia disabilitato](../code-quality/ca5400.md)|Un certificato revocato non è più attendibile. Potrebbe essere utilizzato da utenti malintenzionati che passano alcuni dati dannosi o rubando dati sensibili nella comunicazione HTTPS.|
|[CA5401: Non usare CreateEncryptor con il vettore di inizializzazione non predefinito](../code-quality/ca5401.md)|La crittografia simmetrica deve sempre usare un vettore di inizializzazione non ripetibile per impedire gli attacchi con dizionario.|
|[CA5402: Usa CreateEncryptor con il vettore di inizializzazione predefinito](../code-quality/ca5402.md)|La crittografia simmetrica deve sempre usare un vettore di inizializzazione non ripetibile per impedire gli attacchi con dizionario.|
|[CA5403: Non impostare il certificato come hardcoded](../code-quality/ca5403.md)|Il `data` `rawData` parametro o di un <xref:System.Security.Cryptography.X509Certificates.X509Certificate> <xref:System.Security.Cryptography.X509Certificates.X509Certificate2> costruttore o è hardcoded.|
