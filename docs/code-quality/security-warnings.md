---
title: Avvisi di sicurezza
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 004f10600df3ed2f9c1f62557e0915638482877e
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/01/2020
ms.locfileid: "75587212"
---
# <a name="security-warnings"></a>Avvisi di sicurezza

Gli avvisi di sicurezza supportano librerie e applicazioni più sicure. Questi avvisi contribuiscono ad evitare che il programma presenti difetti nella sicurezza. Se si disabilita uno qualsiasi di questi avvisi, è opportuno indicarne chiaramente il motivo nel codice e informare il responsabile della sicurezza designato per il progetto di sviluppo.

## <a name="in-this-section"></a>In questa sezione

|Regola|Descrizione|
|----------|-----------------|
|[CA2100: Controllare la vulnerabilità della sicurezza nelle query SQL](../code-quality/ca2100.md)|Un metodo imposta la proprietà System.Data.IDbCommand.CommandText usando una stringa compilata da un argomento stringa nel metodo. La regola presuppone che l'argomento stringa contenga l'input dell'utente. Una stringa di comando SQL compilata da un input dell'utente è vulnerabile agli attacchi intrusivi nel codice SQL,|
|[CA2102: Individuare le eccezioni non conformi a CLS nei gestori generali](../code-quality/ca2102.md)|In un membro di un assembly che non è contrassegnato con l'attributo RuntimeCompatibilityAttribute o che è contrassegnato con RuntimeCompatibility(WrapNonExceptionThrows = false) è incluso un blocco catch che gestisce System.Exception e che non contiene un blocco catch generale immediatamente successivo.|
|[CA2103: Controllare la sicurezza imperativa](../code-quality/ca2103.md)|Un metodo usa la sicurezza imperativa e potrebbe costruire l'autorizzazione tramite le informazioni sullo stato o i valori restituiti che possono essere modificati mentre la richiesta è attiva. Usare la sicurezza dichiarativa quando possibile.|
|[CA2104: Non dichiarare tipi di riferimento modificabili in sola lettura](../code-quality/ca2104.md)|Un tipo visibile esternamente contiene un campo in sola lettura visibile esternamente che costituisce un tipo di riferimento modificabile. Un tipo modificabile è un tipo i cui dati di istanza possono essere modificati.|
|[CA2105: I campi di matrici non devono essere di sola lettura](../code-quality/ca2105.md)|Quando si applica il modificatore (ReadOnly in Visual Basic) in sola lettura a un campo contenente una matrice, il campo non può essere modificato in modo da fare riferimento a una matrice diversa. È tuttavia possibile modificare gli elementi della matrice archiviati in un campo in sola lettura.|
|[CA2106: Asserzioni protette](../code-quality/ca2106.md)|Un metodo asserisce un'autorizzazione e non vengono eseguiti controlli di sicurezza sul chiamante. Quando si asserisce un'autorizzazione di sicurezza senza eseguire alcun controllo di sicurezza, nel codice potrebbero restare punti deboli nella sicurezza.|
|[CA2107: Controllare l'utilizzo di Deny e PermitOnly](../code-quality/ca2107.md)|Usare il metodo PermitOnly e le azioni di sicurezza CodeAccessPermission. Deny devono essere usati solo da quelli con una conoscenza avanzata della sicurezza di .NET. Il codice che usa queste azioni di sicurezza deve essere sottoposto a una revisione della sicurezza.|
|[CA2108: Controllare la sicurezza dichiarativa sui tipi di valori](../code-quality/ca2108.md)|Un tipo di valore pubblico o protetto è protetto da richieste di collegamento o accesso ai dati.|
|[CA2109: Controllare i gestori di eventi visibili](../code-quality/ca2109.md)|È stato rilevato un metodo di gestione eventi pubblico o protetto. I metodi di gestione eventi non devono essere esposti se non assolutamente necessario.|
|[CA2111: I puntatori non devono essere visibili](../code-quality/ca2111.md)|Un puntatore non è privato, interno o in sola lettura. Il valore del puntatore può essere modificato dal codice dannoso, consentendo potenzialmente l'accesso a percorsi arbitrari nella memoria o causando errori dell'applicazione o del sistema.|
|[CA2112: I tipi protetti non devono esporre campi](../code-quality/ca2112.md)|In un tipo pubblico o protetto sono inclusi campi pubblici; tale tipo viene protetto da richieste di collegamento. Se il codice ha accesso a un'istanza di un tipo protetta da una richiesta di collegamento, non è necessario che il codice soddisfi la richiesta di collegamento per accedere ai campi del tipo.|
|[CA2114: La sicurezza del metodo deve essere un superset del tipo](../code-quality/ca2114.md)|Un metodo non può presentare sicurezza dichiarativa sia a livello di metodo sia a livello di tipo per la stessa azione.|
|[CA2115: Chiamare GC.KeepAlive durante l'uso di risorse native](../code-quality/ca2115.md)|Questa regola rileva gli errori che possono verificarsi qualora una risorsa non gestita venga completata mentre è ancora usata da codice non gestito.|
|[CA2116: I metodi APTCA devono chiamare solo metodi APTCA](../code-quality/ca2116.md)|Quando l'attributo APTCA (AllowPartiallyTrustedCallers) è presente su un assembly completamente attendibile e l'assembly esegue codice in un altro assembly che non consente chiamanti parzialmente attendibili, è possibile che si verifichi una violazione della sicurezza.|
|[CA2117: I tipi APTCA devono estendere solo tipi di base APTCA](../code-quality/ca2117.md)|Quando l'attributo APTCA (AllowPartiallyTrustedCallers) è presente su un assembly completamente attendibile e un tipo nell'assembly eredita da un tipo che non consente chiamanti parzialmente attendibili, è possibile che si verifichi una violazione della sicurezza.|
|[CA2118: Verificare la sintassi di SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute consente di modificare il comportamento del sistema di sicurezza predefinito per i membri che eseguono codice non gestito mediante interoperabilità COM o chiamata al sistema operativo. Questo attributo viene principalmente usato per aumentare le prestazioni. L'aumento delle prestazioni, tuttavia, comporta notevoli rischi in termini di sicurezza.|
|[CA2119: Impostare come sealed i metodi che soddisfano interfacce private](../code-quality/ca2119.md)|Un tipo pubblico ereditabile fornisce un'implementazione di metodo sottoponibile a override di un'interfaccia interna (Friend in Visual Basic). Per correggere una violazione di questa regola, impedire che venga eseguito l'override del metodo esternamente all'assembly.|
|[CA2120: Proteggere i costruttori di serializzazione](../code-quality/ca2120.md)|Questo tipo dispone di un costruttore che accetta un oggetto System.Runtime.Serialization.SerializationInfo e un oggetto System.Runtime.Serialization.StreamingContext (la firma del costruttore di serializzazione). Questo costruttore non è protetto da un controllo di sicurezza, ma uno o più costruttori regolari nel tipo sono protetti.|
|[CA2121: I costruttori statici devono essere privati](../code-quality/ca2121.md)|Il costruttore statico viene chiamato prima che venga creata la prima istanza del tipo o venga fatto riferimento a qualsiasi membro statico. Se un costruttore statico non è privato, può essere chiamato da codice esterno al sistema. A seconda delle operazioni eseguite nel costruttore, questa situazione può causare comportamenti imprevisti.|
|[CA2122: Non esporre in modo indiretto metodi con richieste di collegamento](../code-quality/ca2122.md)|Un membro pubblico o protetto presenta richieste di collegamento e viene chiamato da un membro che non esegue alcun controllo della sicurezza. Una richiesta di collegamento controlla esclusivamente le autorizzazioni del chiamante immediato.|
|[CA2123: Le richieste di collegamento negli override devono essere identiche a quelle nei metodi di base](../code-quality/ca2123.md)|Questa regola associa un metodo al relativo metodo di base che può essere un'interfaccia o un metodo virtuale in un altro tipo, quindi confronta le richieste di collegamento in ognuno. Se questa regola viene violata, un chiamante malintenzionato può ignorare la richiesta di collegamento chiamando semplicemente il metodo non sicuro.|
|[CA2124: Eseguire il wrapping delle clausole finally vulnerabili in un try esterno](../code-quality/ca2124.md)|Un metodo pubblico o protetto contiene un blocco try/finally. Il blocco finally dovrebbe reimpostare lo stato di sicurezza e non è incluso in un altro blocco finally.|
|[CA2126: Per le richieste di collegamento dei tipi sono necessarie richieste di ereditarietà](../code-quality/ca2126.md)|Un tipo non sealed pubblico è protetto con una richiesta di collegamento e dispone di un metodo sottoponibile a override. Né il tipo né il metodo sono protetti con una richiesta di ereditarietà.|
|[CA2130: Le costanti SecurityCritical devono essere Transparent](../code-quality/ca2130.md)|L'imposizione della trasparenza non viene applicata ai valori costanti perché i compilatori rendono inline valori costanti in modo che non sia richiesta alcuna ricerca in fase di esecuzione. I campi costanti devono essere trasparenti per la sicurezza in modo che i revisori del codice non suppongano che il codice trasparente non possa accedere alla costante.|
|[CA2131: I tipi SecurityCritical possono non partecipare all'equivalenza del tipo](../code-quality/ca2131.md)|Un tipo partecipa all'equivalenza del tipo e il tipo stesso o un membro o un campo del tipo è contrassegnato con l'attributo SecurityCriticalAttribute. Questa regola viene attivata su qualsiasi tipo critico o a tipi che contengono metodi o campi critici che partecipano all'equivalenza del tipo. Quando CLR rileva tale tipo, non lo carica con TypeLoadException in fase di esecuzione. In genere, questa regola funziona solo quando gli utenti implementano l'equivalenza del tipo manualmente piuttosto che basarsi su tlbimp e i compilatori per fare l'equivalenza del tipo.|
|[CA2132: I costruttori predefiniti devono essere Critical almeno come i costruttori predefiniti del tipo base](../code-quality/ca2132.md)|I tipi e i membri che presentano SecurityCriticalAttribute non possono essere usati dal codice dell'applicazione Silverlight. I tipi e i membri critici per la sicurezza possono essere usati solo da codice attendibile nella libreria di classi .NET Framework per Silverlight. Poiché una costruzione pubblica o protetta in una classe derivata deve disporre della trasparenza uguale o superiore alla classe di base, una classe in un'applicazione non può essere derivata da una classe contrassegnata come SecurityCritical.|
|[CA2133: Delegati devono essere associati ai metodi con trasparenza consistente](../code-quality/ca2133.md)|Questo avviso è generato su un metodo che associa un delegato contrassegnato con SecurityCriticalAttribute a un metodo trasparente o contrassegnato con SecuritySafeCriticalAttribute. L'avviso genera anche un metodo che associa un delegato che è trasparente o critico per la sicurezza a un metodo critico.|
|[CA2134: I metodi devono mantenere trasparenza consistente durante l'override dei metodi base](../code-quality/ca2134.md)|Questa regola viene attivata quando un metodo contrassegnato con SecurityCriticalAttribute esegue l'override di un metodo trasparente o contrassegnato con SecuritySafeCriticalAttribute. Questa regola viene inoltre attivata quando un metodo trasparente o contrassegnato con SecuritySafeCriticalAttribute esegue l'override di un metodo contrassegnato con SecurityCriticalAttribute. La regola è applicata in caso di esecuzione dell'override di un metodo virtuale o di implementazione di un'interfaccia.|
|[CA2135: Gli assembly di livello 2 non devono contenere LinkDemands](../code-quality/ca2135.md)|I LinkDemand sono deprecati nel set di regole per la sicurezza di livello 2. Anziché usare i LinkDemand per applicare la sicurezza nella compilazione just-in-time (JIT), contrassegnare i metodi, i tipi e campi con l'attributo SecurityCriticalAttribute.|
|[CA2136: I membri non devono avere annotazioni di trasparenza in conflitto](../code-quality/ca2136.md)|Gli attributi di trasparenza vengono applicati da elementi di codice con un ambito più ampio a elementi con ambito più ridotto. Gli attributi di trasparenza di elementi di codice che presentano un ambito più ampio hanno la precedenza su quelli contenuti nel primo elemento. Ad esempio, una classe contrassegnata con l'attributo SecurityCriticalAttribute non può contenere un metodo contrassegnato con l'attributo SecuritySafeCriticalAttribute.|
|[CA2137: I metodi Transparent devono contenere solo IL verificabile](../code-quality/ca2137.md)|Un metodo contiene codice non verificabile o restituisce un tipo tramite riferimento. Questa regola viene attivata sui tentativi tramite codice trasparente per la sicurezza per eseguire MSIL (Microsoft Intermediate Language) non verificabile. Tuttavia, la regola non contiene un verificatore di IL completo, ma usa invece regole euristiche per intercettare la maggior parte delle violazioni di verifica MSIL.|
|[CA2138: I metodi Transparent non devono chiamare i metodi con l'attributo SuppressUnmanagedCodeSecurity](../code-quality/ca2138.md)|Un metodo trasparente per la sicurezza chiama un metodo contrassegnato con l'attributo SuppressUnmanagedCodeSecurityAttribute.|
|[CA2139: I metodi Transparent non possono usare l'attributo HandleProcessCorruptingExceptions](../code-quality/ca2139.md)|Questa regola viene attivata su qualsiasi metodo trasparente e tenta di gestire un processo che danneggia l'eccezione utilizzando l'attributo HandleProcessCorruptedStateExceptionsAttribute. Un'eccezione che danneggia il processo è una classificazione di eccezioni CLR versione 4,0, ad esempio <xref:System.AccessViolationException>. L'attributo HandleProcessCorruptedStateExceptionsAttribute può essere usato solo dai metodi critici per la sicurezza e sarà ignorato se applicato a un metodo trasparente.|
|[CA2140: Il codice Transparent non deve far riferimento a elementi SecurityCritical](../code-quality/ca2140.md)|I metodi contrassegnati con SecurityTransparentAttribute chiamano membri non pubblici, a loro volta contrassegnati con SecurityCritical. Questa regola analizza tutti i metodi e i tipi in un assembly misto trasparente e critico e contrassegna tutte le chiamate dal codice trasparente al codice critico non pubblico che non sono contrassegnate come SecurityTreatAsSafe.|
|[CA2141:I metodi Transparent non devono soddisfare i LinkDemand](../code-quality/ca2141.md)|Un metodo trasparente per la sicurezza chiama un metodo in un assembly che non è contrassegnato con l'attributo AllowPartiallyTrustedCallersAttribute (APTCA) oppure un metodo trasparente per la sicurezza soddisfa un LinkDemand per un tipo o un metodo.|
|[CA2142: Il codice Transparent non deve essere protetto con LinkDemand](../code-quality/ca2142.md)|Questa regola funziona su metodi trasparenti di cui richiedono a LinkDemands l'accesso. Il codice trasparente per la sicurezza non deve essere responsabile della verifica della sicurezza di un'operazione, pertanto non deve richiedere autorizzazioni.|
|[CA2143: I metodi Transparent non devono usare SecurityDemand](../code-quality/ca2143.md)|Il codice trasparente per la sicurezza non deve essere responsabile della verifica della sicurezza di un'operazione, pertanto non deve richiedere autorizzazioni. Il codice trasparente per la sicurezza deve usare richieste complete per prendere decisioni relative alla sicurezza e il codice critico per la sicurezza non deve basarsi sul codice trasparente per l'esecuzione della richiesta completa.|
|[CA2144: Il codice Transparent non deve caricare assembly da matrici di byte](../code-quality/ca2144.md)|La revisione di sicurezza per il codice trasparente non è accurata come la revisione di sicurezza per il codice critico, perché il primo non può eseguire azioni sensibili per la sicurezza. Assembly caricati da una matrice di byte potrebbero non essere notati nel codice trasparente e quella matrice di byte potrebbe contenere codice critico o ancora più importante codice critico per la sicurezza, che deve essere controllato.|
|[CA2145: I metodi Transparent non devono includere SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|I metodi decorati con l'attributo SuppressUnmanagedCodeSecurityAttribute presentano un LinkDemand implicito su ogni metodo che lo chiama. Questo LinkDemand richiede che il codice che effettua la chiamata sia critico per la sicurezza. Contrassegnare il metodo che usa SuppressUnmanagedCodeSecurity con l'attributo SecurityCriticalAttribute rende più ovvio questo requisito per i chiamanti del metodo.|
|[CA2146: I tipi devono essere Critical almeno come le interfacce e i tipi base relativi](../code-quality/ca2146.md)|Questa regola viene attivata quando un tipo derivato dispone di un attributo di trasparenza di sicurezza che non è critico come il tipo di base o l'interfaccia implementata. Solo i tipi critici possono derivare da tipi di base critici o implementare interfacce critiche e solo tipi critici o critici per la sicurezza possono derivare da tipi di base critici per la sicurezza o implementare interfacce critiche per la sicurezza.|
|[CA2147: Il codice Transparent non può usare asserzioni di sicurezza](../code-quality/ca2147.md)|Questa regola analizza tutti i metodi e i tipi in un assembly trasparente al 100% o trasparente/critico e contrassegna l'utilizzo dichiarativo o imperativo di Assert.|
|[CA2149: I metodi Transparent non devono effettuare chiamate nel codice nativo](../code-quality/ca2149.md)|Questa regola viene attivata su qualsiasi metodo trasparente che chiama direttamente nel codice nativo, ad esempio, tramite P/Invoke. Le violazioni di questa regola conducono a MethodAccessException nel modello di trasparenza di livello 2 e a una richiesta completa per UnmanagedCode nel modello di trasparenza di livello 1.|
|[CA2151: I campi con tipi critici devono essere SecurityCritical](../code-quality/ca2151.md)|Per usare i tipi critici per la sicurezza, il codice che fa riferimento al tipo deve essere critico per la sicurezza critico per la sicurezza e richiamabile da codice trasparente. Questo vale anche se il riferimento è indiretto. Pertanto, un campo trasparente per la sicurezza o critico per la sicurezza e richiamabile da codice trasparente è fuorviante perché il codice trasparente non potrà comunque accedere al campo.|
|[CA2153: Evitare la gestione delle eccezioni in stato danneggiato](../code-quality/ca2153.md)|Le[eccezioni in stato danneggiato (CSE, Corrupted State Exception)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicano che sono presenti danni nella memoria del processo. Se si prova a intercettare tali eccezioni, invece di lasciare che il processo venga arrestato in modo anomalo, può portare a vulnerabilità di sicurezza nel caso in cui un utente malintenzionato riesca a inserire un exploit nell'area della memoria danneggiata.|
|[Ca2300: non usare il deserializzatore non sicuro BinaryFormatter](../code-quality/ca2300.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2301: non chiamare BinaryFormatter. Deserialize senza prima impostare BinaryFormatter. Binder](../code-quality/ca2301.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2302: assicurarsi che BinaryFormatter. Binder sia impostato prima di chiamare BinaryFormatter. Deserialize](../code-quality/ca2302.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2305: non usare un deserializzatore non sicuro LosFormatter](../code-quality/ca2305.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2310: non usare un deserializzatore non sicuro NetDataContractSerializer](../code-quality/ca2310.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2311: non eseguire la deserializzazione senza prima impostare NetDataContractSerializer. Binder](../code-quality/ca2311.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2312: assicurarsi che NetDataContractSerializer. Binder sia impostato prima della deserializzazione](../code-quality/ca2312.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2315: non usare un deserializzatore non sicuro ObjectStateFormatter](../code-quality/ca2315.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2321: non eseguire la deserializzazione con JavaScriptSerializer usando un SimpleTypeResolver](../code-quality/ca2321.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2322: assicurarsi che JavaScriptSerializer non sia inizializzato con SimpleTypeResolver prima della deserializzazione](../code-quality/ca2322.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2326: non usare valori TypeNameHandling diversi da None](../code-quality/ca2326.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2327: non utilizzare JsonSerializerSettings non sicuri](../code-quality/ca2327.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2328: assicurarsi che JsonSerializerSettings siano protetti](../code-quality/ca2328.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2329: non eseguire la deserializzazione con JsonSerializer usando una configurazione non sicura](../code-quality/ca2329.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA2330: assicurarsi che JsonSerializer disponga di una configurazione sicura durante la deserializzazione](../code-quality/ca2330.md)|I deserializzatori non sicuri sono vulnerabili durante la deserializzazione di dati non attendibili. Un utente malintenzionato potrebbe modificare i dati serializzati per includere tipi imprevisti per inserire oggetti con effetti collaterali dannosi.|
|[CA3001: esaminare il codice per le vulnerabilità di SQL injection](../code-quality/ca3001.md)|Quando si utilizzano comandi SQL e input non attendibili, tenere presenti gli attacchi SQL injection. Un attacco SQL injection può eseguire comandi SQL dannosi, compromettendo la sicurezza e l'integrità dell'applicazione.|
|[CA3002: esaminare il codice per le vulnerabilità XSS](../code-quality/ca3002.md)|Quando si utilizza un input non attendibile da richieste Web, tenere presente gli attacchi XSS (cross-site scripting). Un attacco XSS inserisce input non attendibile nell'output HTML non elaborato, consentendo all'autore dell'attacco di eseguire script dannosi o modificare il contenuto nella pagina Web.|
|[Ca3003: esaminare il codice per le vulnerabilità di inserimento di percorsi di file](../code-quality/ca3003.md)|Quando si utilizza un input non attendibile da richieste Web, tenere presente l'utilizzo dell'input controllato dall'utente quando si specificano i percorsi dei file.|
|[Ca3004: esaminare il codice per le vulnerabilità della divulgazione di informazioni](../code-quality/ca3004.md)|La divulgazione delle informazioni sulle eccezioni consente agli utenti malintenzionati di comprendere le caratteristiche interne dell'applicazione, che possono aiutare gli utenti malintenzionati a trovare altre vulnerabilità da sfruttare.|
|[CA3006: esaminare il codice per le vulnerabilità dell'inserimento dei comandi di processo](../code-quality/ca3006.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di inserimento dei comandi. Un attacco injection comando può eseguire comandi dannosi sul sistema operativo sottostante, compromettendo la sicurezza e l'integrità del server.|
|[CA3007: esaminare il codice per le vulnerabilità di reindirizzamento aperte](../code-quality/ca3007.md)|Quando si lavora con un input non attendibile, tenere presenti le vulnerabilità di reindirizzamento aperte. Un utente malintenzionato può sfruttare una vulnerabilità di reindirizzamento aperto per usare il sito Web per dare l'impressione di un URL legittimo, ma reindirizzare un visitatore ignaro a un phishing o ad altre pagine Web dannose.|
|[CA3008: esaminare il codice per le vulnerabilità di inserimento XPath](../code-quality/ca3008.md)|Quando si lavora con un input non attendibile, tenere presenti gli attacchi XPath injection. La costruzione di query XPath tramite input non attendibile può consentire a un utente malintenzionato di manipolare in modo dannoso la query per restituire un risultato imprevisto ed eventualmente divulgare il contenuto dell'XML sottoposto a query.|
|[CA3009: esaminare il codice per le vulnerabilità di inserimento XML](../code-quality/ca3009.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi intrusivi in XML.|
|[CA3010: esaminare il codice per le vulnerabilità di inserimento XAML](../code-quality/ca3010.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di inserimento di XAML. XAML è un linguaggio di markup che rappresenta direttamente la creazione di istanze di oggetti e la relativa esecuzione. Ciò significa che gli elementi creati in XAML possono interagire con le risorse di sistema, ad esempio l'accesso alla rete e file system i/o.|
|[CA3011: esaminare il codice per le vulnerabilità di inserimento di DLL](../code-quality/ca3011.md)|Quando si utilizza un input non attendibile, tenere presente il caricamento di codice non attendibile. Se l'applicazione Web carica codice non attendibile, un utente malintenzionato potrebbe essere in grado di inserire dll dannose nel processo ed eseguire codice dannoso.|
|[CA3012: esaminare il codice per le vulnerabilità di inserimento Regex](../code-quality/ca3012.md)|Quando si lavora con un input non attendibile, tenere presente gli attacchi di attacchi Regex. Un utente malintenzionato può utilizzare l'inserimento Regex per modificare in modo dannoso un'espressione regolare, per fare in modo che l'espressione regolare corrisponda a risultati imprevisti oppure per fare in modo che la regex utilizzi una CPU eccessiva con conseguente attacco Denial of Service.|
|[CA3061: non aggiungere lo schema in base all'URL](../code-quality/ca3061.md)|Non usare l'overload unsafe del metodo Add perché potrebbe causare riferimenti esterni pericolosi.|
|[CA3075: Elaborazione DTD non protetta](../code-quality/ca3075.md)|Se si usano istanze di DTDProcessing non protette o si fa riferimento a origini di entità esterne, il parser può accettare un input non attendibile e divulgare informazioni riservate a utenti malintenzionati.|
|[CA3076: Esecuzione di script XSLT non protetta](../code-quality/ca3076.md)|Se si esegue Extensible Stylesheets Language Transformations (XSLT) in applicazioni .NET in modo non protetto, il processore può risolvere i riferimenti URI non attendibili che potrebbero divulgare informazioni riservate a utenti malintenzionati causando attacchi Denial of Service e XSS.|
|[CA3077: Elaborazione non sicura in progettazione API, documenti XML e lettori di testo XML](../code-quality/ca3077.md)|Quando si progetta un'API derivata da XMLDocument e XMLTextReader, tenere presente DtdProcessing. Se si usano istanze di DTDProcessing non protette per fare riferimento o risolvere origini di entità esterne oppure per impostare valori non protetti nel codice XML, si può causare la divulgazione di informazioni.|
|[CA3147: contrassegna i gestori dei verbi con ValidateAntiForgeryToken](../code-quality/ca3147.md)|Quando si progetta un controller MVC ASP.NET, tenere presenti gli attacchi di richiesta intersito falsa. Un attacco di richiesta intersito falsificazione può inviare richieste dannose da un utente autenticato al controller MVC ASP.NET.|
|[CA5122: Le dichiarazioni P/Invoke non devono essere SafeCritical](../code-quality/ca5122.md)|I metodi sono contrassegnati come SecuritySafeCritical quando viene eseguita un'operazione sensibile di sicurezza, ma possono anche essere usati in sicurezza dal codice trasparente. Il codice trasparente non può mai chiamare direttamente il codice nativo tramite P/Invoke. Di conseguenza, contrassegnare P/Invoke come critico per la sicurezza e richiamabile da codice trasparente non consentirà al codice trasparente di chiamarlo ed è fuorviante per l'analisi di sicurezza.|
|[CA5361: non disabilitare l'uso di crittografia avanzata SChannel](../code-quality/ca5361.md)|Impostando `Switch.System.Net.DontEnableSchUseStrongCrypto` su `true` si indebolisce la crittografia utilizzata nelle connessioni Transport Layer Security in uscita (TLS). La crittografia più debole può compromettere la riservatezza delle comunicazioni tra l'applicazione e il server, semplificando l'intercettazione dei dati sensibili da parte degli utenti malintenzionati.|
|[CA5363: non disabilitare la convalida delle richieste](../code-quality/ca5363.md)|La convalida delle richieste è una funzionalità di ASP.NET che esamina le richieste HTTP e determina se contengono contenuti potenzialmente pericolosi che possono causare attacchi injection, incluso lo scripting tra siti.|
|[CA5364: non usare protocolli di sicurezza deprecati](../code-quality/ca5364.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni precedenti del protocollo TLS sono meno sicure di TLS 1,2 e TLS 1,3 ed è più probabile che abbiano nuove vulnerabilità. Evitare le versioni precedenti del protocollo per ridurre al minimo i rischi.|
|[CA5369: utilizzare XmlReader per la deserializzazione](../code-quality/ca5369.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi, che devono essere limitati utilizzando un oggetto XmlReader con un resolver sicuro oppure con la DTD e l'elaborazione dello schema inline XML disabilitata.|
|[CA5370: utilizzare XmlReader per la convalida del lettore](../code-quality/ca5370.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi. Questo caricamento pericoloso può essere limitato utilizzando un oggetto XmlReader con un resolver sicuro oppure con la DTD e l'elaborazione dello schema inline XML disabilitata.|
|[CA5371: utilizzare XmlReader per la lettura dello schema](../code-quality/ca5371.md)|L'elaborazione di schemi DTD e XML non attendibili può consentire il caricamento di riferimenti esterni pericolosi. L'utilizzo di un oggetto XmlReader con un resolver protetto o con la DTD e l'elaborazione dello schema inline XML disabilitato limita questa operazione.|
|[CA5372: utilizzare XmlReader per XPathDocument](../code-quality/ca5372.md)|L'elaborazione di dati XML da dati non attendibili può caricare riferimenti esterni pericolosi, che possono essere limitati utilizzando un XmlReader con un resolver sicuro o con l'elaborazione DTD disabilitata.|
|[CA5373: non usare la funzione di derivazione della chiave obsoleta](../code-quality/ca5373.md)|Questa regola rileva la chiamata dei metodi di derivazione della chiave debole <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> e `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> ha utilizzato un algoritmo PBKDF1 vulnerabile.|
|[CA5378: non disabilitare ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Impostando `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` su `true` è possibile limitare le connessioni di Windows Communication Framework (WCF) Transport Layer Security (TLS) a utilizzando TLS 1,0. La versione di TLS sarà deprecata.|
|[CA5380: non aggiungere certificati all'archivio radice](../code-quality/ca5380.md)|Questa regola rileva il codice che aggiunge un certificato nell'archivio certificati delle autorità di certificazione radice attendibili. Per impostazione predefinita, l'archivio certificati delle autorità di certificazione radice attendibili è configurato con un set di CA pubbliche che soddisfa i requisiti del programma Microsoft Root Certificate.|
|[CA5381: assicurarsi che i certificati non vengano aggiunti all'archivio radice](../code-quality/ca5381.md)|Questa regola rileva il codice che potenzialmente aggiunge un certificato all'archivio certificati delle autorità di certificazione radice attendibili. Per impostazione predefinita, l'archivio certificati delle autorità di certificazione radice attendibili è configurato con un set di autorità di certificazione pubbliche (CAs) che soddisfano i requisiti del programma Microsoft Root Certificate.|
|[CA5386: evitare il hardcoded del valore SecurityProtocolType](../code-quality/ca5386.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni del protocollo TLS 1,0 e TLS 1,1 sono deprecate, mentre TLS 1,2 e TLS 1,3 sono correnti. In futuro, è possibile che TLS 1,2 e TLS 1,3 siano deprecati. Per assicurarsi che l'applicazione rimanga protetta, evitare di impostare come hardcoded una versione del protocollo e specificare come destinazione almeno .NET Framework v 4.7.1.|
|[CA5389: non aggiungere il percorso dell'elemento di archiviazione al percorso di file system di destinazione](../code-quality/ca5389.md)|Il percorso del file può essere relativo e può comportare l'accesso file system al di fuori del percorso di destinazione file system previsto, causando modifiche di configurazione dannose e l'esecuzione di codice in modalità remota tramite la tecnica Lay-and-wait.|
|[CA5397: non usare valori SslProtocols deprecati](../code-quality/ca5397.md)|ransport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni precedenti del protocollo TLS sono meno sicure di TLS 1,2 e TLS 1,3 ed è più probabile che abbiano nuove vulnerabilità. Evitare le versioni precedenti del protocollo per ridurre al minimo i rischi.|
|[CA5398: evitare valori SslProtocols hardcoded](../code-quality/ca5398.md)|Transport Layer Security (TLS) protegge la comunicazione tra i computer, in genere con Hypertext Transfer Protocol Secure (HTTPS). Le versioni del protocollo TLS 1,0 e TLS 1,1 sono deprecate, mentre TLS 1,2 e TLS 1,3 sono correnti. In futuro, è possibile che TLS 1,2 e TLS 1,3 siano deprecati. Per assicurarsi che l'applicazione rimanga protetta, evitare di impostare come hardcoded una versione del protocollo.|
