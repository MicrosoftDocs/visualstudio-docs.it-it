---
title: "CA2000: Eliminare gli oggetti prima di perdere l'ambito"
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 128b771cde9763183470b52d46dc5137e40cf365
ms.sourcegitcommit: d233ca00ad45e50cf62cca0d0b95dc69f0a87ad6
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 01/01/2020
ms.locfileid: "75584673"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Eliminare gli oggetti prima di perdere l'ambito

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Categoria|Microsoft.Reliability|
|Modifica|Senza interruzioni|

## <a name="cause"></a>Causa

Viene creato un oggetto locale di un tipo di <xref:System.IDisposable>, ma l'oggetto non viene eliminato prima che tutti i riferimenti all'oggetto siano fuori dall'ambito.

Per impostazione predefinita, questa regola analizza l'intera codebase, ma può essere [configurata](#configurability).

## <a name="rule-description"></a>Descrizione della regola

Se un oggetto Disposable non viene eliminato in modo esplicito prima che tutti i relativi riferimenti siano fuori dall'ambito, l'oggetto verrà eliminato in un momento indeterminato quando il Garbage Collector esegue il finalizzatore dell'oggetto. Poiché è possibile che si verifichi un evento eccezionale che impedisce l'esecuzione del finalizzatore dell'oggetto, l'oggetto deve essere eliminato in modo esplicito.

### <a name="special-cases"></a>Casi speciali

La regola CA2000 non viene attivata per gli oggetti locali dei seguenti tipi anche se l'oggetto non è stato eliminato:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Il passaggio di un oggetto di uno di questi tipi a un costruttore e quindi l'assegnazione a un campo indica un *trasferimento di proprietà Dispose* al tipo appena costruito. Ovvero il tipo appena costruito è ora responsabile dell'eliminazione dell'oggetto. Se il codice passa un oggetto di uno di questi tipi a un costruttore, nessuna violazione della regola CA2000 si verifica anche se l'oggetto non viene eliminato prima che tutti i relativi riferimenti siano fuori dall'ambito.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni

Per correggere una violazione di questa regola, chiamare <xref:System.IDisposable.Dispose%2A> sull'oggetto prima che tutti i relativi riferimenti siano fuori dall'ambito.

È possibile utilizzare l' [istruzione`using`](/dotnet/csharp/language-reference/keywords/using-statement) ([`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) in Visual Basic) per eseguire il wrapping degli oggetti che implementano <xref:System.IDisposable>. Gli oggetti di cui viene eseguito il wrapper in questo modo vengono eliminati automaticamente alla fine del blocco `using`. Tuttavia, le situazioni seguenti non devono o non possono essere gestite con un'istruzione `using`:

- Per restituire un oggetto eliminabile, l'oggetto deve essere costruito in un blocco `try/finally` esterno a un blocco di `using`.

- Non inizializzare i membri di un oggetto eliminabile nel costruttore di un'istruzione `using`.

- Quando i costruttori protetti da un solo gestore di eccezioni sono annidati nella [parte di acquisizione di un'istruzione `using`](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement), un errore nel costruttore esterno può comportare la chiusura dell'oggetto creato dal Costruttore annidato. Nell'esempio seguente, un errore nel costruttore di <xref:System.IO.StreamReader> può comportare che l'oggetto <xref:System.IO.FileStream> non venga mai chiuso. CA2000 contrassegna una violazione della regola in questo caso.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Gli oggetti dinamici devono usare un oggetto Shadow per implementare il modello Dispose degli oggetti <xref:System.IDisposable>.

## <a name="when-to-suppress-warnings"></a>Quando escludere gli avvisi

Non eliminare un avviso da questa regola a meno che non sia:

- È stato chiamato un metodo sull'oggetto che chiama `Dispose`, ad esempio <xref:System.IO.Stream.Close%2A>
- Il metodo che ha generato l'avviso restituisce un oggetto <xref:System.IDisposable> che esegue il wrapping dell'oggetto
- Il metodo di allocazione non dispone della proprietà Dispose; ovvero, la responsabilità di eliminare l'oggetto viene trasferita a un altro oggetto o wrapper creato nel metodo e restituito al chiamante.

## <a name="configurability"></a>Configurabilità

Se si esegue questa regola da [analizzatori FxCop](install-fxcop-analyzers.md) (e non con analisi legacy), è possibile configurare l'analisi per questa regola.

### <a name="excluded-symbol-names"></a>Nomi di simboli esclusi

È possibile configurare le parti della codebase da escludere dall'analisi. Ad esempio, per specificare che la regola non deve essere eseguita in alcun codice all'interno di tipi denominati `MyType`, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Formati dei nomi di simboli consentiti nel valore dell'opzione (separati da' |'):
  - Solo nome simbolo (include tutti i simboli con il nome, indipendentemente dal tipo o dallo spazio dei nomi che lo contiene)
  - Nomi completi nel [formato ID documentazione](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)del simbolo. Ogni nome di simbolo richiede un prefisso di tipo simbolo, ad esempio il prefisso "M:" per i metodi, il prefisso "T:" per i tipi, il prefisso "N:" per gli spazi dei nomi e così via.
  - `.ctor` per costruttori e `.cctor` per costruttori statici

Esempi:

| Valore dell'opzione | Riepilogo |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Corrisponde a tutti i simboli denominati ' MyType ' nella compilazione
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Corrisponde a tutti i simboli denominati ' MyType1' o ' MyType2' nella compilazione
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Corrisponde al metodo specifico ' MyMethod ' con la firma completa specificata
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Corrisponde ai metodi specifici ' MyMethod1' è MyMethod2' con la rispettiva firma completa

È possibile configurare tutte queste opzioni solo per questa regola, per tutte le regole o per tutte le regole in questa categoria (progettazione). Per altre informazioni, vedere [configurare gli analizzatori FxCop](configure-fxcop-analyzers.md).

## <a name="related-rules"></a>Regole correlate

- [CA2213: I campi Disposable devono essere eliminati](../code-quality/ca2213.md)
- [CA2202: Non eliminare oggetti più volte](../code-quality/ca2202.md)

## <a name="example"></a>Esempio

Se si sta implementando un metodo che restituisce un oggetto Disposable, usare un blocco try/finally senza un blocco catch per assicurarsi che l'oggetto venga eliminato. Utilizzando un blocco try/finally, si consente la generazione di eccezioni in corrispondenza del punto di errore e assicurarsi che l'oggetto venga eliminato.

Nel metodo OpenPort1 la chiamata per aprire l'oggetto ISerializable SerialPort o la chiamata a SomeMethod può avere esito negativo. In questa implementazione viene generato un avviso CA2000.

Nel metodo OpenPort2 due oggetti SerialPort sono dichiarati e impostati su null:

- `tempPort`, usato per verificare che le operazioni del metodo abbiano esito positivo.

- `port`, usato per il valore restituito del metodo.

Il `tempPort` viene costruito e aperto in un blocco di `try` e tutte le altre operazioni necessarie vengono eseguite nello stesso blocco di `try`. Alla fine del blocco `try`, la porta aperta viene assegnata all'oggetto `port` che verrà restituito e l'oggetto `tempPort` è impostato su `null`.

Il blocco `finally` controlla il valore di `tempPort`. Se non è null, un'operazione nel metodo ha esito negativo e `tempPort` viene chiusa per assicurarsi che tutte le risorse vengano rilasciate. L'oggetto della porta restituita conterrà l'oggetto SerialPort aperto se le operazioni del metodo hanno avuto esito positivo o se un'operazione non è riuscita.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Esempio

Per impostazione predefinita, il compilatore Visual Basic dispone di tutti gli operatori aritmetici che controllano l'overflow. Pertanto, qualsiasi operazione aritmetica Visual Basic potrebbe generare una <xref:System.OverflowException>. Questo potrebbe causare violazioni impreviste in regole come CA2000. La funzione CreateReader1 seguente, ad esempio, genererà una violazione CA2000 perché il compilatore Visual Basic emette un'istruzione di controllo dell'overflow per l'aggiunta che potrebbe generare un'eccezione che provocherebbe la mancata eliminazione di StreamReader.

Per risolvere questo problema, è possibile disabilitare la creazione di controlli di overflow da parte del compilatore Visual Basic nel progetto oppure modificare il codice come nella funzione CreateReader2 seguente.

Per disabilitare la creazione dei controlli di overflow, fare clic con il pulsante destro del mouse sul nome del progetto in Esplora soluzioni e quindi scegliere **Proprietà**. Fare clic su **Compila**, fare clic su **Opzioni di compilazione avanzate**, quindi selezionare **Rimuovi controlli di overflow di Integer**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Vedere anche

- <xref:System.IDisposable>
- [Criterio Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
