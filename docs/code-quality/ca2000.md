---
title: "CA2000: Eliminare gli oggetti prima di perdere l'ambito"
ms.date: 05/14/2019
ms.topic: reference
f1_keywords:
- CA2000
- Dispose objects before losing scope
- DisposeObjectsBeforeLosingScope
helpviewer_keywords:
- CA2000
- DisposeObjectsBeforeLosingScope
ms.assetid: 0c3d7d8d-b94d-46e8-aa4c-38df632c1463
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
- VB
ms.workload:
- multiple
ms.openlocfilehash: 387f1c3d763b15cdbf9ff3cc21375958dc213058
ms.sourcegitcommit: 4bcd6abb89feff1cf8251e3ded73fdc30b67e347
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/17/2020
ms.locfileid: "81615570"
---
# <a name="ca2000-dispose-objects-before-losing-scope"></a>CA2000: Eliminare gli oggetti prima di perdere l'ambito

|||
|-|-|
|TypeName|DisposeObjectsBeforeLosingScope|
|CheckId|CA2000|
|Category|Microsoft.Reliability|
|Modifica|Non-rottura|

## <a name="cause"></a>Causa

Viene creato un <xref:System.IDisposable> oggetto locale di un tipo, ma l'oggetto non viene eliminato prima che tutti i riferimenti all'oggetto esulano dall'ambito.

Per impostazione predefinita, questa regola analizza l'intera codebase, ma è [configurabile.](#configurability)

## <a name="rule-description"></a>Descrizione della regola

Se un oggetto eliminabile non viene eliminato in modo esplicito prima che tutti i riferimenti ad esso siano esterni all'ambito, l'oggetto verrà eliminato in un momento indeterminato quando il Garbage Collector esegue il finalizzatore dell'oggetto. Poiché potrebbe verificarsi un evento eccezionale che impedirà l'esecuzione del finalizzatore dell'oggetto, l'oggetto deve essere eliminato in modo esplicito.

### <a name="special-cases"></a>Casi speciali

La regola CA2000 non viene attivata per gli oggetti locali dei seguenti tipi anche se l'oggetto non viene eliminato:

- <xref:System.IO.Stream?displayProperty=nameWithType>
- <xref:System.IO.StringReader?displayProperty=nameWithType>
- <xref:System.IO.TextReader?displayProperty=nameWithType>
- <xref:System.IO.TextWriter?displayProperty=nameWithType>
- <xref:System.Resources.IResourceReader?displayProperty=nameWithType>

Il passaggio di un oggetto di uno di questi tipi a un costruttore e quindi l'assegnazione a un campo indica un trasferimento di *proprietà dispose* al tipo appena costruito. Ovvero, il tipo appena costruito è ora responsabile per l'eliminazione dell'oggetto. Se il codice passa un oggetto di uno di questi tipi a un costruttore, non si verifica alcuna violazione della regola CA2000 anche se l'oggetto non viene eliminato prima che tutti i riferimenti ad esso non siano esterni all'ambito.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni

Per correggere una violazione <xref:System.IDisposable.Dispose%2A> di questa regola, chiamare l'oggetto prima che tutti i riferimenti ad esso non siano nell'ambito.

È possibile utilizzare[`Using`](/dotnet/visual-basic/language-reference/statements/using-statement) <xref:System.IDisposable> [ `using` l'istruzione](/dotnet/csharp/language-reference/keywords/using-statement) ( in Visual Basic) per eseguire il wrapping degli oggetti che implementano . Gli oggetti di cui viene eseguito il wrapping `using` in questo modo vengono eliminati automaticamente alla fine del blocco. Tuttavia, le seguenti situazioni non devono `using` o non possono essere gestite con un'istruzione:However, the following situations should or cannot be handled with a statement:

- Per restituire un oggetto usa e `try/finally` getta, l'oggetto deve essere costruito in un blocco all'esterno di un `using` blocco.

- Non inizializzare i membri di un `using` oggetto eliminabile nel costruttore di un'istruzione.

- Quando i costruttori protetti da un solo gestore di eccezioni sono annidati nella [parte di acquisizione di un'istruzione `using` ](/dotnet/csharp/language-reference/language-specification/statements#the-using-statement), un errore nel costruttore esterno può causare la chiusura dell'oggetto creato dal costruttore annidato. Nell'esempio seguente, un <xref:System.IO.StreamReader> errore nel costruttore può causare l'oggetto <xref:System.IO.FileStream> non viene mai chiuso. CA2000 segnala una violazione della regola in questo caso.

   ```csharp
   using (StreamReader sr = new StreamReader(new FileStream("C:\myfile.txt", FileMode.Create)))
   { ... }
   ```

- Gli oggetti dinamici devono utilizzare un <xref:System.IDisposable> oggetto shadow per implementare il modello di eliminazione degli oggetti.

## <a name="when-to-suppress-warnings"></a>Quando eliminare gli avvisi

Non escludere un avviso da questa regola a meno che:Do not suppress a warning from this rule unless:

- È stato chiamato un metodo sull'oggetto che chiama `Dispose`, ad esempio<xref:System.IO.Stream.Close%2A>
- Il metodo che ha <xref:System.IDisposable> generato l'avviso restituisce un oggetto che esegue il wrapping dell'oggetto
- Il metodo di allocazione non dispone di proprietà di smaltimento; ovvero la responsabilità di eliminare l'oggetto viene trasferito a un altro oggetto o wrapper creato nel metodo e restituito al chiamante

## <a name="configurability"></a>Configurabilità

Se si esegue questa regola dagli [analizzatori FxCop](install-fxcop-analyzers.md) (e non con l'analisi legacy), è possibile configurare l'analisi per questa regola.

### <a name="excluded-symbol-names"></a>Nomi dei simboli esclusi

È possibile configurare le parti della codebase da escludere dall'analisi. Ad esempio, per specificare che la regola non `MyType`deve essere eseguita su alcun codice all'interno di tipi denominati , aggiungere la seguente coppia chiave-valore a un file con estensione editorconfig nel progetto:

```ini
dotnet_code_quality.CA2000.excluded_symbol_names = MyType
```

Formati di nomi di simboli consentiti nel valore dell'opzione (separati da ''):Allowed symbol name formats in the option value (separated by '''):
  - Solo nome simbolo (include tutti i simboli con il nome, indipendentemente dal tipo o dallo spazio dei nomi che lo contiene)
  - Nomi completi nel formato [ID documentazione](https://github.com/dotnet/csharplang/blob/master/spec/documentation-comments.md#id-string-format)del simbolo . Ogni nome di simbolo richiede un prefisso di tipo simbolo, ad esempio il prefisso "M:" per i metodi, il prefisso "T:" per i tipi, il prefisso "N:" per gli spazi dei nomi e così via.
  - `.ctor`per i `.cctor` costruttori e per i costruttori statici

Esempi:

| Valore dell'opzione | Summary |
| --- | --- |
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType` | Corrisponde a tutti i simboli denominati 'MyType' nella compilazione
|`dotnet_code_quality.CA2000.excluded_symbol_names = MyType1|MyType2` | Corrisponde a tutti i simboli denominati 'MyType1' o 'MyType2' nella compilazione
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS.MyType.MyMethod(ParamType)` | Corrisponde al metodo specifico 'MyMethod' con la firma completa specificata
|`dotnet_code_quality.CA2000.excluded_symbol_names = M:NS1.MyType1.MyMethod1(ParamType)|M:NS2.MyType2.MyMethod2(ParamType)` | Corrisponde a metodi specifici 'MyMethod1' e 'MyMethod2' con la firma completa rispettiva

È possibile configurare tutte queste opzioni solo per questa regola, per tutte le regole o per tutte le regole di questa categoria (Progettazione). Per ulteriori informazioni, consultate [Configurare gli analizzatori FxCop.](configure-fxcop-analyzers.md)

## <a name="related-rules"></a>Regole correlate

- [CA2213: I campi Disposable devono essere eliminati](../code-quality/ca2213.md)
- [CA2202: Non eliminare oggetti più volte](../code-quality/ca2202.md)

## <a name="example"></a>Esempio

Se si implementa un metodo che restituisce un oggetto eliminabile, usare un blocco try/finally senza un blocco catch per assicurarsi che l'oggetto venga eliminato. Utilizzando un blocco try/finally, è possibile generare eccezioni nel punto di errore e assicurarsi che l'oggetto venga eliminato.

Nel metodo OpenPort1, la chiamata per aprire l'oggetto ISerializable SerialPort o la chiamata a SomeMethod può avere esito negativo. Viene generato un avviso CA2000 su questa implementazione.

Nel metodo OpenPort2, due oggetti SerialPort vengono dichiarati e impostati su null:In the OpenPort2 method, two SerialPort objects are declared and set to null:

- `tempPort`, che viene utilizzato per verificare che le operazioni del metodo abbiano esito positivo.

- `port`, utilizzato per il valore restituito del metodo.

Il `tempPort` viene costruito e `try` aperto in un blocco, e `try` qualsiasi altro lavoro richiesto viene eseguito nello stesso blocco. Alla fine del `try` blocco, la porta aperta `port` viene assegnata all'oggetto `tempPort` che verrà `null`restituito e l'oggetto viene impostato su .

Il `finally` blocco controlla `tempPort`il valore di . Se non è null, un'operazione nel `tempPort` metodo non è riuscita e viene chiusa per assicurarsi che tutte le risorse vengono rilasciate. L'oggetto porta restituito conterrà l'oggetto SerialPort aperto se le operazioni del metodo hanno avuto esito positivo oppure sarà null se un'operazione non è riuscita.

```csharp
public SerialPort OpenPort1(string portName)
{
   SerialPort port = new SerialPort(portName);
   port.Open();  //CA2000 fires because this might throw
   SomeMethod(); //Other method operations can fail
   return port;
}

public SerialPort OpenPort2(string portName)
{
   SerialPort tempPort = null;
   SerialPort port = null;
   try
   {
      tempPort = new SerialPort(portName);
      tempPort.Open();
      SomeMethod();
      //Add any other methods above this line
      port = tempPort;
      tempPort = null;

   }
   finally
   {
      if (tempPort != null)
      {
         tempPort.Close();
      }
   }
   return port;
}
```

```vb
Public Function OpenPort1(ByVal PortName As String) As SerialPort

   Dim port As New SerialPort(PortName)
   port.Open()    'CA2000 fires because this might throw
   SomeMethod()   'Other method operations can fail
   Return port

End Function

Public Function OpenPort2(ByVal PortName As String) As SerialPort

   Dim tempPort As SerialPort = Nothing
   Dim port As SerialPort = Nothing

   Try
      tempPort = New SerialPort(PortName)
      tempPort.Open()
      SomeMethod()
      'Add any other methods above this line
      port = tempPort
      tempPort = Nothing

   Finally
      If Not tempPort Is Nothing Then
         tempPort.Close()
      End If

   End Try

   Return port

End Function
```

## <a name="example"></a>Esempio

Per impostazione predefinita, il compilatore Visual Basic dispone di tutti gli operatori aritmetici verificare l'overflow. Pertanto, qualsiasi operazione aritmetica <xref:System.OverflowException>di Visual Basic potrebbe generare un'eccezione . Ciò potrebbe causare violazioni impreviste in regole come CA2000. Ad esempio, la funzione CreateReader1 seguente genererà una violazione CA2000 perché il compilatore Visual Basic genera un'istruzione di controllo dell'overflow per l'aggiunta che potrebbe generare un'eccezione che causerebbe l'eliminazione di StreamReader.

Per risolvere questo problema, è possibile disabilitare l'emissione di controlli di overflow dal compilatore Visual Basic nel progetto oppure è possibile modificare il codice come nella seguente funzione CreateReader2.

Per disabilitare l'emissione di controlli di overflow, fare clic con il pulsante destro del mouse sul nome del progetto in Esplora soluzioni, quindi **scegliere Proprietà**. Fare clic su **Compila**, su **Opzioni avanzate di compilazione**, quindi selezionare **Rimuovi controlli overflow di integer**.

[!code-vb[FxCop.Reliability.CA2000.DisposeObjectsBeforeLosingScope#1](../code-quality/codesnippet/VisualBasic/ca2000-dispose-objects-before-losing-scope-vboverflow_1.vb)]

## <a name="see-also"></a>Vedere anche

- <xref:System.IDisposable>
- [Modello Dispose](/dotnet/standard/design-guidelines/dispose-pattern)
