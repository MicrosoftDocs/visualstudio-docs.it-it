---
title: C26400
ms.date: 08/02/2017
ms.topic: conceptual
f1_keywords:
- C26400
helpviewer_keywords:
- C26400
ms.assetid: b27e1c6d-8b52-40b3-9760-b93afef19c7a
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: ea1e4a708765a173231689cd9c2037a4a20158af
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/07/2019
ms.locfileid: "72016623"
---
# <a name="c26400-no_raw_pointer_assignment"></a>C26400 NO_RAW_POINTER_ASSIGNMENT

Questo controllo consente di applicare il *rule I. 11: Non trasferire mai la proprietà da un puntatore non elaborato (T @ no__t-0)* , che è un subset della regola *R. 3: Un puntatore non elaborato (a T @ no__t-0) non è proprietario.* In particolare, viene visualizzato un avviso su qualsiasi chiamata a operator `new` che salva il risultato in una variabile di tipo puntatore non elaborato. Viene inoltre visualizzato un avviso per le chiamate a funzioni che restituiscono `gsl::owner<T>` se i risultati sono assegnati a puntatori non elaborati. L'idea è che è necessario indicare chiaramente la proprietà delle risorse di memoria. Per ulteriori informazioni, vedere le [ C++ linee guida di base](http://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r-resource-management).

Il modo più semplice per risolvere questo problema consiste nell'usare la dichiarazione `auto` se la risorsa viene assegnata immediatamente alla dichiarazione di variabile. Se ciò non è possibile, è consigliabile usare il tipo `gsl::owner<T>`. Le dichiarazioni `auto` inizializzate con operator `new` sono "owners" perché si presuppone che il risultato di un'allocazione sia implicitamente un puntatore proprietario. Questo presupposto viene trasferito alla variabile `auto` e considerata come `owner<T>`.

Se questo controllo contrassegna una chiamata a una funzione che restituisce `owner<T>`, potrebbe trattarsi di un'indicazione di un bug legittimo nel codice. Fondamentalmente, punta a una posizione in cui il codice perde una nozione esplicita di proprietà (e forse la risorsa stessa).

## <a name="remarks"></a>Note

Questa regola controlla attualmente solo le variabili locali. Se l'allocazione viene assegnata a un parametro formale, a una variabile globale, a un membro di classe e così via, non viene contrassegnato. Una copertura appropriata di tali scenari è parte del lavoro futuro.

## <a name="example-1-simple-allocation"></a>Esempio 1: Allocazione semplice

```cpp
char *buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // C26400
```

## <a name="example-2-simple-allocation-fixed-with-gslownert"></a>Esempio 2 Allocazione semplice (correzione con GSL:: Owner @ no__t-0T >)

```cpp
gsl::owner<char*> buffer = nullptr;
if (useCache)
    buffer = GetCache();
else
    buffer = new char[bufferSize];  // OK

Example 3: Simple allocation (fixed with auto)
auto buffer = useCache ? GetCache() : new char[bufferSize]; // OK
```
