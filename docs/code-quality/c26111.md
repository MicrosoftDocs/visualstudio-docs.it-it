---
title: C26111 | Documenti Microsoft
ms.custom: 
ms.date: 11/04/2016
ms.reviewer: 
ms.suite: 
ms.technology: vs-ide-code-analysis
ms.tgt_pltfrm: 
ms.topic: article
f1_keywords: C26111
helpviewer_keywords: C26111
ms.assetid: 85fc740a-3bbb-41b8-a848-95e243a08da9
caps.latest.revision: "8"
author: mikeblome
ms.author: mblome
manager: ghogen
ms.workload: multiple
ms.openlocfilehash: dadc0c15e07595d3a35d4cb4a92f257bdcdf3490
ms.sourcegitcommit: 32f1a690fc445f9586d53698fc82c7debd784eeb
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 12/22/2017
---
# <a name="c26111"></a>C26111
avviso C26111: chiamante non riesce a rilasciare il blocco \<blocco > prima di chiamare funzione \<func >.  
  
 L'annotazione `_Requires_lock_not_held_` impone una precondizione che il conteggio dei blocchi per il blocco specificato non può essere maggiore di zero quando viene chiamata la funzione. C26111 avviso viene generato quando una funzione non riesce a rilasciare il blocco prima di chiamare un'altra funzione.  
  
## <a name="example"></a>Esempio  
 Nell'esempio seguente genera l'avviso C26111 perché il `_Requires_lock_not_held_` precondizione viene violata dalla chiamata a `DoNotLock` all'interno della sezione bloccata.  
  
```  
  
typedef struct _DATA   
{  
    CRITICAL_SECTION cs;  
    int d;  
} DATA;  
  
_Requires_lock_not_held_(p->cs)   
  
void DoNotLock(DATA* p)  
{  
    EnterCriticalSection(&p->cs);   
    p->d = 0;  
    LeaveCriticalSection(&p->cs);  
}  
  
void LockedFunction(DATA* p)   
{   
    EnterCriticalSection(&p->cs);   
    DoNotLock(p); // Warning C26111  
    LeaveCriticalSection(&p->cs);  
}  
  
```