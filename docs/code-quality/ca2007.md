---
title: "CA2007: Non attendere direttamente un'attività"
ms.date: 03/08/2019
ms.topic: reference
f1_keywords:
- CA2007
- DoNotDirectlyAwaitATaskAnalyzer
helpviewer_keywords:
- CA2007
author: mikejo5000
ms.author: mikejo
manager: jillfra
dev_langs:
- CSharp
ms.openlocfilehash: f55cc992c443b034ccfbf444db4b3ca705b2b698
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "89219621"
---
# <a name="ca2007-do-not-directly-await-a-task"></a>CA2007: Non attendere direttamente un'attività

|Elemento|valore|
|-|-|
|CheckId|Ca2007|
|Category|Microsoft. affidabilità|
|Modifica|Senza interruzioni|

## <a name="cause"></a>Causa

Un metodo asincrono [attende](/dotnet/csharp/language-reference/keywords/await) direttamente un oggetto <xref:System.Threading.Tasks.Task> .

## <a name="rule-description"></a>Descrizione della regola

Quando un metodo asincrono attende direttamente un oggetto <xref:System.Threading.Tasks.Task> , la continuazione si verifica generalmente nello stesso thread che ha creato l'attività, a seconda del contesto asincrono. Questo comportamento può essere oneroso in termini di prestazioni e può causare un deadlock sul thread UI. Prendere <xref:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)?displayProperty=nameWithType> in considerazione la chiamata a per segnalare l'intenzione di continuare.

## <a name="how-to-fix-violations"></a>Come correggere le violazioni

Per correggere le violazioni, chiamare <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> sull'oggetto atteso <xref:System.Threading.Tasks.Task> . È possibile passare `true` o `false` per il `continueOnCapturedContext` parametro.

- La chiamata all' `ConfigureAwait(true)` attività ha lo stesso comportamento di non chiamare in modo esplicito <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> . Chiamando in modo esplicito questo metodo, si lascia che i lettori sappiano che si vuole intenzionalmente eseguire la continuazione nel contesto di sincronizzazione originale.

- Chiamare `ConfigureAwait(false)` sull'attività per pianificare le continuazioni nel pool di thread, evitando in tal modo un deadlock sul thread UI. `false`Il passaggio è un'opzione efficace per le librerie indipendenti dall'app.

## <a name="when-to-suppress-warnings"></a>Quando escludere gli avvisi

Questo avviso è destinato alle librerie, in cui il codice può essere eseguito in ambienti arbitrari e in cui il codice non deve creare presupposti sull'ambiente o su come il chiamante del metodo può essere chiamato o in attesa. In genere è consigliabile evitare completamente l'avviso per i progetti che rappresentano il codice dell'applicazione anziché il codice della libreria; in realtà, l'esecuzione di questo analizzatore sul codice dell'applicazione (ad esempio, i gestori di eventi click del pulsante in un progetto WinForms o WPF) può causare le azioni non corrette eseguite.

È possibile disattivare questo avviso in qualsiasi situazione in cui la continuazione deve essere pianificata di nuovo nel contesto originale o in cui non è presente alcun contesto di questo tipo. Ad esempio, quando si scrive il codice in un gestore dell'evento click del pulsante in un'applicazione WinForms o WPF, in generale la continuazione di un await deve essere eseguita sul thread dell'interfaccia utente e pertanto il comportamento predefinito della pianificazione della continuazione al contesto di origine è auspicabile. Come altro esempio, quando si scrive il codice in un'applicazione ASP.NET Core, per impostazione predefinita non è presente alcun <xref:System.Threading.SynchronizationContext> o <xref:System.Threading.Tasks.TaskScheduler> , per il quale il motivo a `ConfigureAwait` non cambierebbe effettivamente alcun comportamento.

## <a name="example"></a>Esempio

Il frammento di codice seguente genera l'avviso:

```csharp
public async Task Execute()
{
    Task task = null;
    await task;
}
```

Per correggere la violazione, chiamare <xref:System.Threading.Tasks.Task.ConfigureAwait%2A> sull'oggetto atteso <xref:System.Threading.Tasks.Task> :

```csharp
public async Task Execute()
{
    Task task = null;
    await task.ConfigureAwait(false);
}
```

## <a name="configurability"></a>Configurabilità

È possibile specificare se si desidera escludere i metodi asincroni che non restituiscono un valore da questa regola. Per escludere questi tipi di metodi, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
# Package version 2.9.0 and later
dotnet_code_quality.CA2007.exclude_async_void_methods = true

# Package version 2.6.3 and earlier
dotnet_code_quality.CA2007.skip_async_void_methods = true
```

È anche possibile configurare i tipi di assembly di output a cui applicare la regola. Ad esempio, per applicare questa regola solo al codice che produce un'applicazione console o una libreria collegata dinamicamente, ovvero non un'app dell'interfaccia utente, aggiungere la coppia chiave-valore seguente a un file con estensione EditorConfig nel progetto:

```ini
dotnet_code_quality.CA2007.output_kind = ConsoleApplication, DynamicallyLinkedLibrary
```

Per altre informazioni, vedere [configurare gli analizzatori di qualità del codice .NET](configure-fxcop-analyzers.md).

## <a name="see-also"></a>Vedere anche

- [Domande frequenti su ConfigureAwait](https://devblogs.microsoft.com/dotnet/configureawait-faq/)
- [È necessario attendere un'attività con ConfigureAwait (false)?](https://github.com/Microsoft/vs-threading/blob/master/doc/cookbook_vs.md#should-i-await-a-task-with-configureawaitfalse)
- [CA2008: Non creare attività senza passare un elemento TaskScheduler](ca2008.md)
- [Avvisi di affidabilità](reliability-warnings.md)
