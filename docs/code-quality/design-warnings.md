---
title: Regole di progettazione
ms.date: 11/04/2016
ms.topic: reference
f1_keywords:
- vs.codeanalysis.designrules
helpviewer_keywords:
- design rules
- managed code analysis rules, design rules
- rules, design
ms.assetid: 34e65a18-560c-423f-814f-519089e318cf
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
ms.openlocfilehash: 1d626231bcfe298a225cc916c356290a94042992
ms.sourcegitcommit: 566144d59c376474c09bbb55164c01d70f4b621c
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/19/2020
ms.locfileid: "90808665"
---
# <a name="design-rules"></a>Regole di progettazione

Le regole di progettazione supportano la conformità alle [linee guida di progettazione .NET Framework](/dotnet/standard/design-guidelines/).

## <a name="in-this-section"></a>Contenuto della sezione

| Regola | Descrizione |
| - | - |
| [CA1000: Non dichiarare membri statici su tipi generici](../code-quality/ca1000.md) | Quando viene chiamato un membro statico di un tipo generico, è necessario specificare l'argomento di tipo. Quando viene chiamato un membro di istanza generica che non supporta l'inferenza, è necessario specificare l'argomento tipo relativo al membro. In questi due casi, la sintassi necessaria per specificare l'argomento di tipo è diversa e può generare confusione. |
| [CA1001: I tipi proprietari di campi Disposable devono essere Disposable](../code-quality/ca1001.md) | Una classe dichiara e implementa un campo di istanza che è un tipo System. IDisposable e la classe non implementa IDisposable. Una classe che dichiara un campo IDisposable è indirettamente proprietaria di una risorsa non gestita e deve implementare l'interfaccia IDisposable. |
| [CA1002: Non esporre elenchi generici](../code-quality/ca1002.md) | System. Collections. Generic. list< (of \<(T> ) >) è una raccolta generica progettata per le prestazioni, non per l'ereditarietà. List, pertanto, non contiene membri virtuali. Devono invece essere esposte le raccolte generiche che sono state progettate per l'ereditarietà. |
| [CA1003: Usare istanze di gestori eventi generici](../code-quality/ca1003.md) | Un tipo contiene un delegato che restituisce void, la cui firma contiene due parametri (il primo oggetto e il secondo un tipo assegnabile a EventArgs) e l'assembly contenitore ha come destinazione .NET Framework 2,0. |
| [CA1005: Evitare un uso eccessivo di parametri nei tipi generici](../code-quality/ca1005.md) | Quanto più è alto il numero di parametri di tipo contenuti, maggiore è la difficoltà di sapere e ricordare cosa rappresenta ciascun parametro. È in genere ovvio con un parametro di tipo, come nell'elenco \<T> , e in alcuni casi con due parametri di tipo, come in Dictionary \<TKey, TValue> . Tuttavia, se il numero dei parametri di tipo è superiore a due, il livello di difficoltà sarà troppo elevato per la maggior parte degli utenti. |
| [CA1008: Le enumerazioni devono avere valore zero](../code-quality/ca1008.md) | Il valore predefinito di un'enumerazione non inizializzata, come altri tipi di valore, è zero. Un'enumerazione con attributi non flag deve definire un membro usando il valore zero, in modo che il valore predefinito sia un valore valido dell'enumerazione. Se un'enumerazione a cui è applicato l'attributo FlagsAttribute definisce un membro con valore zero, il relativo nome deve essere "None" per indicare che nell'enumerazione non è stato impostato alcun valore. |
| [CA1010: Le raccolte devono implementare un'interfaccia generica](../code-quality/ca1010.md) | Per ampliare la possibilità di utilizzo di una raccolta, implementare una delle interfacce di raccolta generiche. La raccolta può quindi essere utilizzata per popolare tipi di raccolte generiche. |
| [CA1012: I tipi astratti non devono includere costruttori](../code-quality/ca1012.md) | I costruttori sui tipi astratti possono essere chiamati solo da tipi derivati. Poiché i costruttori pubblici creano istanze di un tipo e non è possibile creare istanze di un tipo astratto, per una buona progettazione non bisognerebbe creare un tipo astratto con costruttore pubblico. |
| [CA1014: Contrassegnare gli assembly con CLSCompliantAttribute](../code-quality/ca1014.md) | In Common Language Specification (CLS) vengono definite limitazioni di denominazione, tipi di dati e regole che gli assembly devono rispettare per poter essere utilizzati tra diversi linguaggi di programmazione. Una progettazione efficace impone che tutti gli assembly indichino in modo esplicito la conformità a CLS usando CLSCompliantAttribute. Se questo attributo non è presente in un assembly, tale assembly non è conforme. |
| [CA1016: Contrassegnare gli assembly con AssemblyVersionAttribute](../code-quality/ca1016.md) | .NET usa il numero di versione per identificare in modo univoco un assembly e per eseguire il binding ai tipi in assembly con nome sicuro. Il numero di versione viene utilizzato insieme ai criteri di versione ed editore. Per impostazione predefinita, le applicazioni vengono eseguite solo con la versione di assembly con cui sono state compilate. |
| [CA1017: Contrassegnare gli assembly con ComVisibleAttribute](../code-quality/ca1017.md) | ComVisibleAttribute determina il modo in cui i client COM accedono al codice gestito. In una buona progettazione gli assembly devono indicare in modo esplicito la visibilità COM. È possibile impostare la visibilità COM per l'intero assembly e quindi eseguirne l'override per singoli tipi e membri dei tipi. Se questo attributo non è presente, il contenuto dell'assembly è visibile ai client COM. |
| [CA1018: Contrassegnare gli attributi con AttributeUsageAttribute](../code-quality/ca1018.md) | Quando si definisce un attributo personalizzato, contrassegnarlo tramite AttributeUsageAttribute per indicare la posizione nel codice sorgente in cui applicare l'attributo personalizzato. Il significato e l'utilizzo previsto di un attributo ne determinano le posizioni valide nel codice. |
| [CA1019: Definire le funzioni di accesso per gli argomenti degli attributi](../code-quality/ca1019.md) | Gli attributi possono definire argomenti obbligatori che devono essere specificati quando si applica l'attributo a una destinazione. Sono inoltre noti come argomenti posizionali poiché vengono forniti ai costruttori di attributo come parametri posizionali. Per ogni argomento obbligatorio, l'attributo deve fornire anche una proprietà in sola lettura corrispondente in modo che il valore dell'argomento possa essere recuperato in fase di esecuzione. Gli attributi possono inoltre definire argomenti facoltativi, noti anche come argomenti denominati. Questi argomenti sono forniti ai costruttori degli attributi in base al nome e devono disporre di una proprietà in lettura e scrittura corrispondente. |
| [CA1021: Evitare parametri out](../code-quality/ca1021.md) | Il passaggio di tipi per riferimento (mediante out o ref) richiede esperienza nell'utilizzo dei puntatori, nonché la conoscenza delle differenze tra tipi di valore e tipi di riferimento e dei metodi di gestione con più valori restituiti. Inoltre, la differenza tra parametri out e ref non è sempre nota. |
| [CA1024: Usare proprietà dove appropriato](../code-quality/ca1024.md) | Un metodo pubblico o protetto presenta un nome che inizia con "Get", non accetta parametri e restituisce un valore diverso da una matrice. Il metodo presenta tutte le caratteristiche per diventare una proprietà. |
| [CA1027: Contrassegnare le enumerazioni con FlagsAttribute](../code-quality/ca1027.md) | Un'enumerazione è un tipo di valore che definisce un insieme di costanti denominate correlate. Applicare FlagsAttribute a un'enumerazione quando le relative costanti denominate possono essere combinate in modo significativo. |
| [CA1028: Le risorse di archiviazione dell'enumerazione devono essere Int32](../code-quality/ca1028.md) | Un'enumerazione è un tipo di valore che definisce un insieme di costanti denominate correlate. Per impostazione predefinita, il tipo di dati System.Int32 viene utilizzato per archiviare il valore costante. Anche se è possibile modificare questo tipo sottostante, non è obbligatorio o consigliato per la maggior parte degli scenari. |
| [CA1030: Usare eventi dove appropriato](../code-quality/ca1030.md) | Questa regola rileva i metodi che presentano nomi comunemente utilizzati per gli eventi. Se un metodo viene chiamato in risposta a una modifica dello stato chiaramente definita, il metodo deve essere richiamato da un gestore eventi. Gli oggetti che chiamano il metodo devono generare eventi anziché chiamare direttamente il metodo. |
| [CA1031: Non rilevare tipi di eccezione generali](../code-quality/ca1031.md) | Le eccezioni generali non devono essere rilevate. Rilevare un'eccezione più specifica o rigenerare l'eccezione generale come ultima istruzione nel blocco catch. |
| [CA1032: Implementare costruttori di eccezioni standard](../code-quality/ca1032.md) | Se non viene fornito l'insieme completo di costruttori può risultare difficile gestire correttamente le eccezioni. |
| [CA1033: I metodi di interfaccia devono essere richiamabili dai tipi figlio](../code-quality/ca1033.md) | Un tipo visibile esternamente non sealed fornisce un'implementazione di metodo esplicita di un'interfaccia pubblica e non fornisce un metodo visibile esternamente alternativo con lo stesso nome. |
| [CA1034: I tipi annidati non devono essere visibili](../code-quality/ca1034.md) | Un tipo annidato è un tipo dichiarato nell'ambito di un altro tipo. I tipi annidati sono utili per incapsulare dettagli di implementazione privati del tipo contenitore. I tipi annidati utilizzati per questo scopo non devono essere visibili esternamente. |
| [CA1036: Eseguire l'override di metodi su tipi confrontabili](../code-quality/ca1036.md) | Un tipo pubblico o protetto implementa l'interfaccia System.IComparable. Non esegue l'override di Object.Equals né l'overload dell'operatore specifico del linguaggio per uguaglianza, ineguaglianza, minore di o maggiore di. |
| [CA1040: Evitare l'uso di interfacce vuote](../code-quality/ca1040.md) | Le interfacce definiscono membri che forniscono un comportamento o un contratto di utilizzo. La funzionalità descritta dall'interfaccia può essere adottata da qualsiasi tipo, indipendentemente dal punto in cui il tipo è visualizzato nella gerarchia di ereditarietà. Un tipo implementa un'interfaccia fornendo implementazioni per i membri dell'interfaccia. Un'interfaccia vuota non definisce alcun membro. Di conseguenza, non definisce un contratto implementabile. |
| [CA1041: Specificare una proprietà ObsoleteAttribute.Message](../code-quality/ca1041.md) | Un tipo o un membro viene contrassegnato utilizzando un attributo System.ObsoleteAttribute per cui non è stata specificata la proprietà ObsoleteAttribute.Message. Quando viene compilato un tipo o un membro contrassegnato tramite ObsoleteAttribute, viene visualizzata la proprietà Message dell'attributo, che fornisce le informazioni sull'utente sul tipo o sul membro obsoleto. |
| [CA1043: Usare un argomento di tipo stringa o integrale per gli indicizzatori](../code-quality/ca1043.md) | Gli indicizzatori, ovvero le proprietà indicizzate, devono utilizzare tipi integrali o stringa per l'indice. Questi tipi vengono in genere utilizzati per l'indicizzazione di strutture di dati e aumentano l'utilizzabilità della libreria. L'utilizzo del tipo Object deve essere limitato ai casi in cui non sia possibile specificare in fase di progettazione il tipo integrale o stringa. |
| [CA1044: Le proprietà non devono essere in sola scrittura](../code-quality/ca1044.md) | Sebbene la presenza di proprietà di sola lettura sia accettabile e spesso necessaria, le linee guida di progettazione proibiscono l'utilizzo di proprietà di sola scrittura. Ciò è dovuto al fatto che consentire a un utente di impostare un valore e quindi impedirgli di visualizzarlo, non offre alcuna sicurezza. Inoltre, senza accesso in lettura, lo stato degli oggetti condivisi non può essere visualizzato, il che ne limita l'utilità. |
| [CA1045: Non passare i tipi per riferimento](../code-quality/ca1045.md) | Il passaggio di tipi per riferimento (mediante out o ref) richiede esperienza nell'utilizzo dei puntatori, nonché la conoscenza delle differenze tra tipi di valore e tipi di riferimento e dei metodi di gestione con più valori restituiti. Gli architetti di librerie destinate a un pubblico generico non devono aspettarsi che gli utenti siano in grado di utilizzare i parametri out o ref. |
| [CA1046: Non eseguire l'overload dell'operatore "uguale a" per i tipi di riferimento](../code-quality/ca1046.md) | Per i tipi di riferimento, l'implementazione predefinita dell'operatore di uguaglianza è quasi sempre corretta. Per impostazione predefinita, i due riferimenti sono uguali solo se puntano allo stesso oggetto. |
| [CA1047: Non dichiarare membri protected nei tipi sealed](../code-quality/ca1047.md) | I tipi dichiarano membri protetti in modo che i tipi che ereditano possano accedere al membro o eseguirne l'override. Per definizione, non è possibile ereditare tipi sealed, pertanto non è possibile chiamare metodi protetti su tipi sealed. |
| [CA1050: Dichiarare i tipi negli spazi dei nomi](../code-quality/ca1050.md) | I tipi vengono dichiarati in spazi dei nomi per impedire conflitti di denominazione e per organizzare i tipi correlati in una gerarchia di oggetti. |
| [CA1051: Non dichiarare campi di istanza visibili](../code-quality/ca1051.md) | L'utilizzo principale di un campo deve essere come dettaglio di implementazione. I campi devono essere privati o interni e devono essere esposti tramite proprietà. |
| [CA1052: I tipi che contengono membri statici devono essere sealed](../code-quality/ca1052.md) | Un tipo pubblico o protetto contiene solo membri statici e non è dichiarato con il modificatore sealed (C#) o NotInheritable (Visual Basic). Un tipo non adatto a essere ereditato deve essere contrassegnato utilizzando il modificatore sealed per impedire che venga utilizzato come tipo di base. |
| [CA1053: I tipi che contengono membri statici non devono avere costruttori](../code-quality/ca1053.md) | Un tipo pubblico o annidato dichiara solo membri statici e presenta un costruttore predefinito pubblico o protetto. Il costruttore non è necessario perché la chiamata a membri statici non richiede un'istanza del tipo. A scopo di sicurezza e protezione, l'overload dei valori di stringa deve chiamare l'overload URI tramite l'argomento stringa. |
| [CA1054: I parametri URI non devono essere stringhe](../code-quality/ca1054.md) | Se un metodo accetta una rappresentazione in forma di stringa di un URI, è necessario fornire un overload corrispondente che accetti un'istanza della classe URI che fornisce questi servizi in modo sicuro e protetto. |
| [CA1055: I valori restituiti URI non devono essere stringhe](../code-quality/ca1055.md) | Questa regola presuppone che il metodo restituisca un URI. Una rappresentazione in forma di stringa di un URI è soggetta a errori di analisi e codifica e può creare vulnerabilità nella sicurezza. La classe System.Uri fornisce questi servizi in modo sicuro e protetto. |
| [CA1056: Le proprietà URI non devono essere stringhe](../code-quality/ca1056.md) | Questa regola presuppone che la proprietà rappresenti un URI. Una rappresentazione in forma di stringa di un URI è soggetta a errori di analisi e codifica e può creare vulnerabilità nella sicurezza. La classe System.Uri fornisce questi servizi in modo sicuro e protetto. |
| [CA1058: I tipi non devono estendere tipi di base specifici](../code-quality/ca1058.md) | Un tipo visibile esternamente estende tipi di base specifici. Utilizzare una delle alternative seguenti: |
| [CA1060: spostare i P/Invoke nella classe NativeMethods](../code-quality/ca1060.md) | I metodi di chiamata della piattaforma, ad esempio quelli contrassegnati con i <xref:System.Runtime.InteropServices.DllImportAttribute?displayProperty=fullName> metodi o definiti usando la parola chiave Declare in [!INCLUDE[vbprvb](../code-quality/includes/vbprvb_md.md)] , accedono al codice non gestito. Questi metodi devono appartenere alla classe NativeMethods, SafeNativeMethods o UnsafeNativeMethods. |
| [CA1061: Non nascondere i metodi di una classe base](../code-quality/ca1061.md) | Un metodo di un tipo di base è nascosto da un metodo denominato in modo identico in un tipo derivato, quando la firma del parametro del metodo derivato differisce solo per i tipi che presentano una derivazione più debole rispetto ai tipi corrispondenti nella firma del parametro del metodo di base. |
| [CA1062: Convalidare gli argomenti di metodi pubblici](../code-quality/ca1062.md) | È necessario che tutti gli argomenti di riferimento passati a metodi visibili esternamente vengano sottoposti a verifica per accertarsi che non corrispondano a valori Null. |
| [CA1063: Implementare IDisposable correttamente](../code-quality/ca1063.md) | È necessario che tutti i tipi IDisposable implementino correttamente il modello Dispose. |
| [CA1064: Le eccezioni devono essere pubbliche](../code-quality/ca1064.md) | Un'eccezione interna è visibile solo nel relativo ambito interno. Se l'eccezione si verifica al di fuori dell'ambito interno, può essere rilevata solo tramite l'eccezione di base. Se l'eccezione interna viene ereditata da <xref:System.Exception?displayProperty=fullName> , <xref:System.SystemException?displayProperty=fullName> o <xref:System.ApplicationException?displayProperty=fullName> , il codice esterno non disporrà di informazioni sufficienti per sapere cosa fare con l'eccezione. |
| [CA1065: Non generare eccezioni in posizioni non previste](../code-quality/ca1065.md) | Un metodo che normalmente non genera eccezioni genera un'eccezione. |
| [CA1066: Implementare IEquatable quando si esegue l'override di Equals](../code-quality/ca1066.md) | Un tipo di valore esegue l'override del <xref:System.Object.Equals%2A> metodo, ma non implementa <xref:System.IEquatable%601> . |
| [CA1067: Esegue l'override di Equals quando si implementa IEquatable](../code-quality/ca1067.md) | Un tipo implementa <xref:System.IEquatable%601> , ma non esegue l'override del <xref:System.Object.Equals%2A> metodo. |
| [CA1068: I parametri CancellationToken devono essere indicati per ultimi](../code-quality/ca1068.md) | Un metodo ha un parametro CancellationToken che non è l'ultimo parametro. |
| [CA1069: Le enumerazioni non devono contenere valori duplicati](../code-quality/ca1069.md) | Un'enumerazione dispone di più membri a cui viene assegnato in modo esplicito lo stesso valore costante. |
| [CA1070: Non dichiarare i campi evento come virtuali](../code-quality/ca1070.md) | Un [evento di tipo campo](/dotnet/csharp/language-reference/language-specification/classes#field-like-events) è stato dichiarato come virtuale. |
