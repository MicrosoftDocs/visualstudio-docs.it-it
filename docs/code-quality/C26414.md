---
title: C26414
ms.date: 11/15/2017
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: markl
ms.workload:
- multiple
ms.openlocfilehash: 8ced283edb792ee917706974070dce407cc29f5a
ms.sourcegitcommit: 535ef05b1e553f0fc66082cd2e0998817eb2a56a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/07/2019
ms.locfileid: "72011682"
---
# <a name="c26414-reset_local_smart_ptr"></a>C26414 RESET_LOCAL_SMART_PTR

"Spostare, copiare, riassegnare o reimpostare un puntatore intelligente locale".

Linee guida principali: **C++** R. 5: Preferisci oggetti con ambito, non allocare inutilmente nell'heap

I puntatori intelligenti sono utili per la gestione dinamica delle risorse, ma non sono sempre necessari. Ad esempio, la creazione di un buffer dinamico locale può essere facilmente (termine a volte più efficiente) gestita da contenitori standard. Per gli oggetti singoli, potrebbe non essere necessario eseguire l'allocazione dinamica, ad esempio se tali oggetti non sopravvivono mai a una funzione di autore, e possono essere sostituiti con variabili locali. I puntatori intelligenti diventano utili quando lo scenario richiede la modifica della proprietà, ovvero la riassegnazione di una risorsa dinamica più volte o in più percorsi. Sono inclusi anche i casi in cui le risorse vengono ottenute dal codice esterno e i puntatori intelligenti vengono usati per estendere la durata della risorsa.

## <a name="remarks"></a>Note

- Oltre ai modelli std:: unique_pointer e std:: shared_pointer standard, questo controllo riconosce i tipi definiti dall'utente che probabilmente sono progettati come puntatori intelligenti. Tali tipi sono previsti per definire le operazioni seguenti:
  - operatori di dereferenziazione o di accesso ai membri in overload, pubblici e non contrassegnati come eliminati;
  - distruttore pubblico che non viene eliminato né impostato come predefinito. Sono inclusi i distruttori che vengono definiti in modo esplicito vuoto.
  - Il tipo Microsoft:: WRL:: ComPtr si comporta come un puntatore condiviso, ma viene spesso usato in scenari piuttosto specifici che sono interessati dalla gestione della durata COM. Per evitare un rumore eccessivo, questo tipo è filtrato.
  - Questo controllo Cerca le allocazioni locali esplicite assegnate ai puntatori intelligenti per identificare se le variabili con ambito possono essere Word come alternativa. Oltre alle chiamate dirette a operator new, le funzioni speciali come std:: make_unique e std:: make_shared vengono interpretate anche come allocazioni dirette.

## <a name="example"></a>Esempio

buffer dinamico

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```

buffer dinamico: sostituito dal contenitore

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
