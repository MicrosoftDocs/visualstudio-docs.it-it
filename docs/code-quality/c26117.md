---
title: C26117
ms.date: 11/04/2016
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26117
helpviewer_keywords:
- C26117
ms.assetid: cc7ebc8d-9826-4cad-a4d5-2d3ad5896734
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 0aa58b86e71fd6a645227d03da8fa0e5e117dbe3
ms.sourcegitcommit: 42ea834b446ac65c679fa1043f853bea5f1c9c95
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 04/19/2018
---
# <a name="c26117"></a>C26117
avviso C26117: il rilascio di blocco si \<blocco > nella funzione \<func >.

 L'applicazione di blocco con ambito sintatticamente *acquisire* e blocco *versione* coppie nei programmi C/C++ non viene eseguita dal linguaggio. Una funzione può comportare un effetto collaterale blocco apportando una modifica allo stato concorrenza observable. Ad esempio, una funzione wrapper blocco incrementa il numero di acquisizioni di blocchi o conteggio dei blocchi, per un determinato blocco. È possibile annotare una funzione che ha un effetto secondario da un blocco di acquisire o il rilascio del blocco tramite `_Acquires_lock_` o `_Releases_lock_`, rispettivamente. Senza tali annotazioni, è prevista una funzione non di modificare qualsiasi numero di blocchi dopo la restituzione. Se viene acquisita e le versioni non sono bilanciate, sono considerati *orfani*. C26117 avviso viene generato quando una funzione che non è stata annotata con `_Releases_lock_` rilascia un blocco che non mantiene attivo, perché la funzione deve essere proprietaria del blocco prima che lo rilascia.

## <a name="example"></a>Esempio
 Nell'esempio seguente genera l'avviso C26117 perché la funzione `ReleaseUnheldLock` rilascia un blocco che non necessariamente contenere, lo stato di `flag` è ambiguo, ed è presente alcuna annotazione che specifica che deve.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
        EnterCriticalSection(&p->cs);
    // code ...
    LeaveCriticalSection(&p->cs);
}
```

## <a name="example"></a>Esempio
 Il codice seguente consente di correggere il problema assicurando che il blocco rilasciato viene acquisito anche nelle stesse condizioni.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
    {
        EnterCriticalSection(&p->cs);
        // code ...
        LeaveCriticalSection(&p->cs);
    }
}
```

## <a name="see-also"></a>Vedere anche
 [C26115](../code-quality/c26115.md)