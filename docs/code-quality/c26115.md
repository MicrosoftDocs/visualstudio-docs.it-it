---
title: C26115
ms.date: 11/04/2016
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26115
helpviewer_keywords:
- C26115
ms.assetid: 3977a2bb-d1fe-4510-89dd-07fdc69e911c
author: mikeblome
ms.author: mblome
manager: wpickett
ms.workload:
- multiple
ms.openlocfilehash: 7227d5319152c398bd33e661962471e41660ddaf
ms.sourcegitcommit: 240c8b34e80952d00e90c52dcb1a077b9aff47f6
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 10/23/2018
ms.locfileid: "49822891"
---
# <a name="c26115"></a>C26115
avviso C26115: riesce a rilasciare il blocco \<lock > nella funzione \<func >.

 Imposizione del blocco con ambito sintatticamente *acquisire* e il blocco *rilasciare* coppie nei programmi C/C++ non viene eseguita dal linguaggio. Una funzione può comportare un effetto collaterale blocco apportando una modifica allo stato di concorrenza osservabile. Ad esempio, una funzione wrapper blocco incrementa il numero di acquisizioni di blocco o di conteggio dei blocchi, di un blocco specificato.

 È possibile annotare una funzione che ha un effetto collaterale di un blocco di acquisizione o rilascio del blocco usando `_Acquires_lock_` o `_Releases_lock_`, rispettivamente. Senza annotazioni di questo tipo, una funzione non dovrebbe modificare qualsiasi numero di blocchi dopo aver restituito. Se acquisisce e le versioni non siano bilanciate, sono considerati *orfani*. Avviso C26115 viene generato quando una funzione introduce un blocco orfano.

## <a name="example"></a>Esempio
 Nell'esempio seguente genera l'avviso C26115 essendo presente un blocco orfano in una funzione che non è annotata con `_Acquires_lock_`.

```

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

void FailToReleaseLock(int flag, DATA* p)
{
    EnterCriticalSection(&p->cs);

    if (flag)
        return; // Warning C26115

    LeaveCriticalSection(&p->cs);
}
```