---
title: C26117 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C26117
helpviewer_keywords:
- C26117
ms.assetid: cc7ebc8d-9826-4cad-a4d5-2d3ad5896734
caps.latest.revision: 13
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: ff941f72cc15c318fe84e6f6dd673f297bf66233
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "77266530"
---
# <a name="c26117"></a>C26117
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

avviso C26117: è in seguito il rilascio di un blocco non mantenuto \<lock> nella funzione \<func> .

L'applicazione di coppie di blocchi di *acquisizione* e di *rilascio* di blocchi con ambito sintattico nei programmi C/C++ non viene eseguita dal linguaggio. Una funzione può introdurre un effetto collaterale di blocco effettuando una modifica osservabile dello stato di concorrenza. Una funzione wrapper di blocco, ad esempio, incrementa il numero di acquisizioni di blocchi o il numero di blocchi per un determinato blocco. È possibile aggiungere annotazioni a una funzione che ha un effetto collaterale da un blocco Acquisisci o blocca rilascio usando `_Acquires_lock_` `_Releases_lock_` rispettivamente o. Senza tali annotazioni, non è previsto che una funzione modifichi il conteggio dei blocchi dopo che è stato restituito. Se le acquisizioni e le versioni non sono bilanciate, vengono considerate *orfane*. L'avviso C26117 viene emesso quando una funzione che non è stata annotata con `_Releases_lock_` rilascia un blocco che non contiene, perché la funzione deve essere proprietaria del blocco prima di rilasciarla.

## <a name="example"></a>Esempio
L'esempio seguente genera l'avviso C26117 perché la funzione `ReleaseUnheldLock` rilascia un blocco che non è necessariamente in attesa, ovvero lo stato di `flag` è ambiguo e non esiste alcuna annotazione che specifichi che deve essere.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
        EnterCriticalSection(&p->cs);
    // code ...
    LeaveCriticalSection(&p->cs);
}
```

## <a name="example"></a>Esempio
Il codice seguente consente di risolvere il problema garantendo che anche il blocco rilasciato venga acquisito nelle stesse condizioni.

```cpp

typedef struct _DATA
{
    CRITICAL_SECTION cs;
} DATA;

int flag;

void ReleaseUnheldLock(DATA* p)
{
    if (flag)
    {
        EnterCriticalSection(&p->cs);
        // code ...
        LeaveCriticalSection(&p->cs);
    }
}
```

## <a name="see-also"></a>Vedere anche
[C26115](../code-quality/c26115.md)
