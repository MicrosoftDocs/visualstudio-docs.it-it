---
title: C6011 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6011
helpviewer_keywords:
- C6011
ms.assetid: 54b7bc2b-b8f5-43fc-a9a3-8189b03f249a
caps.latest.revision: 31
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 8586ead4860b9c69dfd6ad0d7cf392199127650d
ms.sourcegitcommit: 68f893f6e472df46f323db34a13a7034dccad25a
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 02/15/2020
ms.locfileid: "77277512"
---
# <a name="c6011"></a>C6011
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

avviso C6011: dereferenziazione del puntatore NULL \<nome >  
  
 Questo avviso indica che è in corso la dereferenziazione di un puntatore null. Se il valore del puntatore non è valido, il risultato sarà indefinito.  
  
## <a name="example"></a>Esempio  
 Il codice seguente genera questo avviso perché una chiamata a malloc potrebbe restituire null se la memoria disponibile è insufficiente:  
  
```  
#include <malloc.h>  
  
void f( )  
{   
  char *p = ( char * ) malloc( 10 );  
  *p = '\0';  
  
  // code ...  
 free( p );  
}  
```  
  
 Per correggere il problema, esaminare il puntatore per un valore null, come illustrato nel codice seguente:  
  
```  
#include <malloc.h>  
void f( )  
{  
  char *p = ( char * )malloc ( 10 );  
  if ( p )   
  {  
    *p = '\0';  
    // code ...  
  
    free( p );  
  }  
}  
```  
  
 È necessario allocare memoria all'interno della funzione i cui parametri sono annotati utilizzando la proprietà null in una condizione preliminare prima di dereferenziare il parametro. Il codice seguente genera l'avviso C6011 perché viene effettuato un tentativo di dereferenziare un puntatore null (`pc`) all'interno della funzione senza prima allocare memoria:  
  
```  
#include <sal.h>  
using namespace vc_attributes;  
void f([Pre(Null=Yes)] char* pc)  
{  
  *pc='\0'; // warning C6011 - pc is null  
  // code ...  
}  
```  
  
 L'uso di malloc e Free presenta molti problemi in termini di perdite di memoria ed eccezioni. Per evitare completamente questi tipi di perdite e problemi di eccezione, utilizzare i meccanismi forniti dalla libreria STL ( C++ Standard Template Library). Sono inclusi [shared_ptr](https://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](https://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a)e [vector](https://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Per altre informazioni, vedere [puntatori intelligenti](https://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) e [ C++ libreria standard](https://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
## <a name="see-also"></a>Vedere anche  
 [Cenni preliminari sulle Annotazioni](https://msdn.microsoft.com/2345380e-2eeb-4107-907f-6e8b809c2643)   
 [Null](https://msdn.microsoft.com/632f3684-60a0-45be-aeb1-be1521e94d88)   
   [null](https://msdn.microsoft.com/library/f9aac2a0-4f79-423f-8738-a76dccc0b1c3)  
 [Operatori di riferimento indiretto e address-of](https://msdn.microsoft.com/library/10d62b00-12ba-4ea9-a2d5-09ac29ca2232)   
 [malloc](https://msdn.microsoft.com/library/144fcee2-be34-4a03-bb7e-ed6d4b99eea0)   
 [free](https://msdn.microsoft.com/library/74ded9cf-1863-432e-9306-327a42080bb8)
