---
title: C28182 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C28182
helpviewer_keywords:
- C28182
ms.assetid: efec8b1f-8994-4a09-aaaf-6afaadfde883
caps.latest.revision: 7
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: 0621ee33f25e3be9c1e9445d587e99c24e75fe92
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "77272109"
---
# <a name="c28182"></a>C28182
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

avviso C28182: dereferenziazione del puntatore NULL.  
  
 **Informazioni aggiuntive**: *\<pointer1>* contiene lo stesso valore null *\<pointer2>**\<note>*  
  
 Lo strumento di analisi del codice segnala questo avviso quando conferma che il puntatore può essere NULL. Se sono presenti istanze non confermate in cui l'errore potrebbe verificarsi in precedenza nella traccia, lo strumento di analisi del codice aggiunge il numero di riga della prima istanza al messaggio di avviso in modo che sia possibile modificare il codice per indirizzare tutte le istanze.  
  
 *\<pointer2>* è confermato come potenzialmente NULL. *\<pointer1>* contiene lo stesso valore di *pointer2* e viene dereferenziato. Poiché questi puntatori possono trovarsi in posizioni molto diverse nel codice, entrambi vengono segnalati in modo che sia possibile determinare il motivo per cui lo strumento di analisi del codice segnala questo avviso.  
  
 Se è presente un'istanza precedente non confermata della condizione, *\<note>* viene sostituito da questo testo: "vedere la riga *\<number>* relativa a una posizione precedente in cui può verificarsi questa situazione".  
  
## <a name="example"></a>Esempio  
 Nell'esempio seguente viene illustrato il codice che può causare la generazione di questo messaggio di avviso da parte dello strumento di analisi del codice. In questo esempio, lo strumento di analisi del codice determina che `pNodeFree` è null nell' `if` istruzione e viene utilizzato il percorso del codice nel corpo di `if` . Tuttavia, poiché `nBlockSize` è potenzialmente zero, il corpo dell' `for` istruzione non viene eseguito e `pNodeFree` viene lasciato invariato. `pNodeFree` viene quindi assegnato a `pNode` e `pNode` viene utilizzato mentre è possibile che si verifichi una dereferenziazione null.  
  
```  
typedef struct xlist {  
    struct xlist *pNext;  
    struct xlist *pPrev;  
} list;  
  
list *pNodeFree;  
list *masterList;  
int nBlockSize;  
  
void fun()  
{  
    if (pNodeFree == 0)  
    {  
        list *pNode = masterList;  
  
        for (int i = nBlockSize-1; i >= 0; i--, pNode--)  
        {  
            pNode->pNext = pNodeFree;  
            pNodeFree = pNode;  
        }  
    }  
  
    list* pNode = pNodeFree;  
    pNode->pPrev = 0;  
}  
  
```  
  
 Lo strumento di analisi del codice segnala l'avviso seguente:  
  
```  
:\sample\testfile.cpp(24) : warning C28182: Dereferencing NULL pointer. 'pNode' contains the same NULL value as 'pNodeFree' did.: Lines: 12, 14, 16, 23, 24  
```  
  
## <a name="example"></a>Esempio  
 Un modo per correggere l'esempio precedente consiste nel verificare la presenza `pNode` di zero prima di dereferenziarlo in modo che venga evitata una dereferenziazione null. Il codice seguente illustra questa correzione.  
  
```  
typedef struct xlist {  
    struct xlist *pNext;  
    struct xlist *pPrev;  
} list;  
  
list *pNodeFree;  
list *masterList;  
int nBlockSize;  
  
void fun()  
{  
    if (pNodeFree == 0)  
    {  
        list *pNode = masterList;  
  
        for (int i = nBlockSize-1; i >= 0; i--, pNode--)  
        {  
            pNode->pNext = pNodeFree;  
            pNodeFree = pNode;  
        }  
    }  
  
    list* pNode = pNodeFree;  
    if(pNode != 0)  
      pNode->pPrev = 0;  
}  
  
```
