---
title: C6384 | Microsoft Docs
ms.date: 11/15/2016
ms.prod: visual-studio-dev14
ms.technology: vs-ide-code-analysis
ms.topic: reference
f1_keywords:
- C6384
helpviewer_keywords:
- C6384
ms.assetid: 9c605b61-1485-49a8-847b-41170193dbf4
caps.latest.revision: 14
author: corob-msft
ms.author: corob
manager: jillfra
ms.openlocfilehash: c421bc27c4e61231f4a2eb88d1fad2dc1c50d154
ms.sourcegitcommit: 6cfffa72af599a9d667249caaaa411bb28ea69fd
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 09/02/2020
ms.locfileid: "77277744"
---
# <a name="c6384"></a>C6384
[!INCLUDE[vs2017banner](../includes/vs2017banner.md)]

avviso C6384: divisione di un puntatore sizeof per un altro valore  
  
 Questo avviso indica che un calcolo delle dimensioni potrebbe non essere corretto. Per calcolare il numero di elementi in una matrice, una a volte divide la dimensione della matrice in base alla dimensione del primo elemento. Tuttavia, quando la matrice è effettivamente un puntatore, il risultato è in genere diverso da quello previsto.  
  
 Se il puntatore è un parametro di funzione e le dimensioni del buffer non sono state passate, non è possibile calcolare il buffer massimo disponibile. Quando il puntatore viene allocato localmente, è necessario utilizzare la dimensione utilizzata nell'allocazione.  
  
## <a name="example"></a>Esempio  
 Il codice seguente genera questo avviso:  
  
```  
#include <windows.h>  
#include <TCHAR.h>  
  
#define SIZE 15  
  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
    _tcsncpy(dest, src, sizeof dest  / sizeof dest[0]);   
  }  
}  
```  
  
 Per correggere il problema, passare le dimensioni del buffer, come illustrato nel codice seguente:  
  
```  
#include <windows.h>  
#include <TCHAR.h>  
  
#define SIZE 15  
  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
    _tcsncpy(dest, src, SIZE);  
  }  
}  
```  
  
 Per correggere questo avviso utilizzando la funzione di stringa sicura _tcsncpy_s, utilizzare il codice seguente:  
  
```  
void f( )  
{  
  LPTSTR dest = new TCHAR[SIZE];  
  char src [SIZE] = "Hello, World!!";  
  if (dest)  
  {  
   _tcsncpy_s(dest, SIZE, src, SIZE);  
  }  
}   
```  
  
 Si noti che l'uso di New e Delete presenta molti problemi in termini di perdite di memoria ed eccezioni. Per evitare completamente questi tipi di perdite e problemi di eccezione, utilizzare i meccanismi forniti dalla libreria STL (Standard Template Library) di C++. Sono inclusi [shared_ptr](https://msdn.microsoft.com/library/1469fc51-c658-43f1-886c-f4530dd84860), [unique_ptr](https://msdn.microsoft.com/library/acdf046b-831e-4a4a-83aa-6d4ee467db9a)e [vector](https://msdn.microsoft.com/library/c1431ad8-c0b6-4dbb-89c4-5f651e432d7f). Per altre informazioni, vedere [puntatori intelligenti](https://msdn.microsoft.com/library/909ef870-904c-49b6-b8cd-e9d0b7dc9435) e [libreria standard C++](https://msdn.microsoft.com/library/a37d3ba3-58af-47c7-9ee2-441ccd7b77ee).  
  
## <a name="see-also"></a>Vedere anche  
 [_mbsnbcpy_s, _mbsnbcpy_s_l](https://msdn.microsoft.com/library/dfff64ab-fe6f-49c4-99ba-75014e2b0cd6)   
 [Operatore sizeof](https://msdn.microsoft.com/library/8bc3b6fb-54a1-4eb7-ada0-05f8c5efc532)
